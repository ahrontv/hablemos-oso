<!DOCTYPE html>
<!-- saved from url=(0102)file:///D:/Users/atver/Documents%20PC/githubDdrive/languageSite/languages/eng/letter-practice-eng.html -->
<!-- Consistently use JSDoc -->
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
    <title>Letter Drawing Practice</title>
    <style>
        /* Container styles */
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
            margin: 20px;
        }

        /* Canvas container with relative positioning for layering */
        #canvas-container {
            position: relative;
            width: 300px;
            height: 300px;
        }

        /* Canvas layers stacked using z-index */
        canvas {
            position: absolute;
            border: 1px solid #ccc;
            touch-action: none; /* Prevents default touch actions on mobile */
        }

        #ruleCanvas {
            z-index: 1;
        }
        /* Bottom layer: ruled paper */
        #completedCanvas {
            z-index: 3;
        }
        /* completed strokes */
        #letterCanvas {
            z-index: 2;
        }
        /* second to bottom layer: font letter */
        #guideCanvas {
            z-index: 4;
        }
        /* Middle layer: guide strokes */
        #drawCanvas {
            z-index: 5;
        }
        /* Top layer: current drawing */

        /* Controls container */
        .controls {
            display: flex;
            gap: 10px;
            margin: 10px 0;
        }

        /* UI element styles */
        button, select {
            margin: 10px;
            padding: 8px 16px;
            font-size: 16px;
            cursor: pointer;
        }

            button:hover {
                background-color: #f0f0f0;
            }

        #instruction {
            margin: 10px;
            font-size: 18px;
            color: #444;
        }

        #accuracy {
            margin: 10px;
            font-size: 16px;
            color: #666;
        }

        #letterSelect {
            margin: 10px;
            padding: 5px;
            font-size: 16px;
        }
        /* Top controls */
        .top-controls {
            width: 300px;
            display: flex;
            justify-content: center;
            margin-bottom: 10px;
        }
        /* Previous styles remain the same */
        /* Add arrow animation */
        @keyframes moveArrow {
            0% {
                transform: translateX(0) translateY(0);
            }

            50% {
                transform: translateX(10px) translateY(10px);
            }

            100% {
                transform: translateX(0) translateY(0);
            }
        }

        .arrow {
            position: absolute;
            pointer-events: none;
            animation: moveArrow 1.5s infinite;
        }
        /* Next Letter button */
        #nextLetterBtn {
            margin-left: 10px;
            padding: 5px 10px;
            font-size: 16px;
            cursor: pointer;
        }

        /* Letter input container and elements */
        .letter-input-container {
            display: flex;
            margin-left: 10px;
            align-items: center;
        }

        #letterInput {
            width: 40px;
            height: 28px;
            padding: 4px;
            font-size: 16px;
            text-align: center;
            border: 1px solid #ccc;
            border-radius: 4px 0 0 4px;
        }

        #goToLetterBtn {
            height: 38px;
            padding: 4px 8px;
            font-size: 14px;
            border-radius: 0 4px 4px 0;
            cursor: pointer;
            margin-left: 0;
        }
    </style>
</head>
<body>
    <h1>Letter Drawing Practice</h1>
    <div class="top-controls">
        <select id="letterSelect"><option value="f">Letter f</option><option value="A">Letter A</option><option value="B">Letter B</option><option value="C">Letter C</option><option value="D">Letter D</option><option value="E">Letter E</option><option value="F">Letter F</option><option value="G">Letter G</option><option value="H">Letter H</option><option value="I">Letter I</option><option value="J">Letter J</option><option value="K">Letter K</option><option value="L">Letter L</option><option value="M">Letter M</option><option value="N">Letter N</option><option value="O">Letter O</option><option value="P">Letter P</option><option value="Q">Letter Q</option><option value="R">Letter R</option><option value="S">Letter S</option><option value="T">Letter T</option><option value="U">Letter U</option><option value="V">Letter V</option><option value="W">Letter W</option><option value="X">Letter X</option><option value="Y">Letter Y</option><option value="Z">Letter Z</option><option value="a">Letter a</option><option value="b">Letter b</option><option value="c">Letter c</option><option value="d">Letter d</option><option value="e">Letter e</option><option value="g">Letter g</option><option value="h">Letter h</option><option value="i">Letter i</option><option value="j">Letter j</option><option value="k">Letter k</option><option value="l">Letter l</option><option value="m">Letter m</option><option value="n">Letter n</option><option value="o">Letter o</option><option value="p">Letter p</option><option value="q">Letter q</option><option value="r">Letter r</option><option value="s">Letter s</option><option value="t">Letter t</option><option value="u">Letter u</option><option value="v">Letter v</option><option value="w">Letter w</option><option value="x">Letter x</option><option value="y">Letter y</option><option value="z">Letter z</option></select>
        <!-- Add these new elements -->
        <button id="nextLetterBtn">Next Letter</button>
        <div class="letter-input-container">
            <input type="text" id="letterInput" maxlength="1" placeholder="Type a letter">
            <button id="goToLetterBtn">Go</button>
        </div>
    </div>
    <div id="instruction" style="color: rgb(68, 68, 68);">Follow the highlighted stroke</div>
    <div id="canvas-container">
        <canvas id="ruleCanvas" width="300" height="300"></canvas>
        <canvas id="completedCanvas" width="300" height="300"></canvas>
        <canvas id="letterCanvas" width="300" height="300"></canvas>
        <canvas id="guideCanvas" width="300" height="300"></canvas>
        <canvas id="drawCanvas" width="300" height="300"></canvas>
    </div>
    <div class="controls">
        <button id="resetBtn">Reset</button>
        <button id="autoDrawBtn">Auto Draw</button>
        <button id="toggleRule">Ruled Paper?</button>
    </div>
    <div id="accuracy"></div>

    <script>
        /**
         * Letter Drawing Practice App
         *
         * This application helps users practice drawing letters by following stroke guides.
         * It uses multiple canvas layers for drawing, guides, and completed strokes.
         * Features include stroke validation, accuracy measurement, and support for both
         * straight and curved strokes.

         TODO - update to handle error when fully drawn
         - add method to progress to next stroke app.nextStroke
         - ensure that the current stroke is on top. completed strokes then future strokes then current stroke then arrows
         - make sure the letter word matches the language ie en:Letter es:Letra - ui.letterPrefix
         TODO - when letter is fully drawn cause the drawing actiion to launch confetti
         TODO - allow strokes to regulate their own accuracy requirements
         */

        /**
         * Configuration system with language-specific overrides
         */
        // Base configuration with defaults
        const BaseConfig = {
            canvas: {
                width: 300,
                height: 300,
                layers: ['rule', 'letter', 'completed', 'guide', 'draw'] // order matters here. increasing zindex
            },
            rulePaper: true,
            ruledLines: [
                { y: 0.75, style: 'solid', color: '#000000', width: 2 },    // Bottom solid black 220 .7333 225 .75 222 .74
                { y: 0.55, style: 'dashed', color: 'rgba(255,0,0,0.3)', width: 1 }, // Middle red 165
                { y: 0.15, style: 'dashed', color: 'rgba(0,0,255,0.3)', width: 1 }  // Top blue   45
            ],
            direction: "ltr",
            styles: {
                rule: { color: '#FFA500', lineWidth: 3 / 300 },
                guide: { color: '#dddddd', lineWidth: 20 / 300, lineCap: 'round' },
                highlight: { color: '#ffeb3b', lineWidth: 20 / 300, lineCap: 'round' },
                completed: { color: '#ff1111', lineWidth: 20 / 300, lineCap: 'round' },
                arrow: { color: '#FFA500', lineWidth: 3 / 300, lineCap: 'butt', headLength: 15 / 300, headWidth: 10 / 300 }
            },
            accuracy: {
                threshold: 50,
                samplePoints: 50,
                maxError: 100
            },
            animation: {
                duration: 1000
            },
            // Default UI text
            ui: {
                title: 'Letter Drawing Practice',
                resetButton: 'Reset',
                autoDrawButton: 'Auto Draw',
                toggleRuleButton: 'Ruled Paper?',
                completedMessage: 'Great job! Letter completed!',
                followStrokeMessage: 'Follow the highlighted stroke',
                nextLetterButton: 'Next Letter',
                goButton: 'Go',
                letterInputPlaceholder: 'Type a letter',
                letterPrefix: 'Letter'
            },
            // When printing font
            letterStyle: {
                font: 'bold 250px Arial',
                color: '#DDDDDD',
                align: 'center',
                baseline: 'middle'
            }
        };

        // Language-specific configuration overrides missing last three for some
        const LanguageConfigs = {
            'en': {
                // English is the base language, no overrides needed
            },
            'es': {
                // Spanish overrides
                ui: {
                    title: 'Práctica de Escritura de Letras',
                    resetButton: 'Reiniciar',
                    autoDrawButton: 'Dibujo Automático',
                    toggleRuleButton: '¿Papel Rayado?',
                    completedMessage: '¡Buen trabajo! ¡Letra completada!',
                    followStrokeMessage: 'Sigue el trazo resaltado',
                    nextLetterButton: 'Siguiente Letra',
                    goButton: 'Ir',
                    letterInputPlaceholder: 'Escribe una letra',
                    letterPrefix: 'Letra'
                }
            },
            'jp': {
                // Japanese overrides
                ui: {
                    title: '文字描画練習',
                    resetButton: 'リセット',
                    autoDrawButton: '自動描画',
                    toggleRuleButton: '罫線表示',
                    completedMessage: 'よくできました！文字完成！',
                    followStrokeMessage: 'ハイライトされた線をなぞってください'
                },
                // Different stroke accuracy settings for Japanese characters
                accuracy: {
                    threshold: 60, // Higher threshold for more complex characters
                    samplePoints: 75, // More sample points for detailed evaluation
                    maxError: 80 // Smaller max error tolerance
                }
            },
            'he': {
                // Hebrew overrides (right-to-left language)
                ui: {
                    title: 'תרגול כתיבת אותיות',
                    resetButton: 'איפוס',
                    autoDrawButton: 'ציור אוטומטי',
                    toggleRuleButton: 'נייר שורות?',
                    completedMessage: 'עבודה טובה! האות הושלמה!',
                    followStrokeMessage: 'עקוב אחר הקו המודגש'
                },
                // RTL specific settings
                direction: 'rtl'
            }
        };

        /**
         * Configuration loader that merges base config with language-specific overrides
         */
        class ConfigLoader {
            constructor() {
                this.languageParam = this.getLanguageFromUrl();
                this.config = this.loadConfig();
                // make style objects
                Object.entries(this.config.styles).forEach(([key, value]) => {
                    this.config.styles[key] = new StrokeStyle(value, this.config); // Modifies the original object
                });
            }

            /**
             * Extract language parameter from URL
             */
            getLanguageFromUrl() {
                const urlParams = new URLSearchParams(window.location.search);
                return urlParams.get('lang') || 'en'; // Default to English
            }

            /**
             * Deep merge objects. ex Base Config and Language specific configs. souce overwrites target where keys overlap.
             */
            deepMerge(target, source) {
                const output = Object.assign({}, target);

                if (isObject(target) && isObject(source)) {
                    Object.keys(source).forEach(key => {
                        if (isObject(source[key])) {
                            if (!(key in target)) {
                                Object.assign(output, { [key]: source[key] });
                            } else {
                                output[key] = this.deepMerge(target[key], source[key]);
                            }
                        } else {
                            Object.assign(output, { [key]: source[key] });
                        }
                    });
                }

                return output;

                function isObject(item) {
                    return (item && typeof item === 'object' && !Array.isArray(item));
                }
            }


            /**
             * Load and merge configuration
             */
            loadConfig() {
                // Get language-specific config (or empty object if language not supported)
                const langConfig = LanguageConfigs[this.languageParam] || {};

                // Deep merge with base config
                return this.deepMerge(BaseConfig, langConfig);
            }

            /**
             * Get current configuration
             */
            getConfig() {
                return this.config;
            }

            /**
             * Get language-specific letter data
             */
            async loadLetterData() {
                try {
                    // Load language-specific letter definitions
                    try {
                        var response = await fetch(`./data/letters-${this.languageParam}.json`);
                        console.log('letters loaded');
                    } catch (error) {
                        var response = {
                            'A': {
                                strokes: [
                                    { type: 'line', points: [{ x: 150 / 300, y: 45 / 300 }, { x: 80 / 300, y: 215 / 300 }] },
                                    { type: 'line', points: [{ x: 150 / 300, y: 45 / 300 }, { x: 220 / 300, y: 215 / 300 }] },
                                    { type: 'line', points: [{ x: 100 / 300, y: 165 / 300 }, { x: 200 / 300, y: 165 / 300 }] }

                                ],
                                randomField: {},
                                fontStrokes: [
                                    {
                                        type: 'compound', subStrokes: [
                                            {
                                                type: 'line', points: [{ x: 150 / 300, y: 60 / 300 }, { x: 94 / 300, y: 180 / 300 }]
                                            },
                                            { type: 'line', points: [{ x: 94 / 300, y: 180 / 300 }, { x: 70 / 300, y: 230 / 300 }], lWidth: 80 / 300, lineCap: 'butt' }, // size cap butt square
                                        ]
                                    },
                                ]
                            },
                            'B': {
                                strokes: [
                                    { type: 'line', points: [{ x: 95 / 300, y: 55 / 300 }, { x: 95 / 300, y: 205 / 300 }] },
                                    {
                                        type: 'compound', subStrokes: [{
                                            type: 'line',
                                            points: [{ x: 95 / 300, y: 55 / 300 }, { x: 150 / 300, y: 55 / 300 }]
                                        },
                                        {
                                            type: 'curve',
                                            points: [{ x: 150 / 300, y: 55 / 300 }, { x: 220 / 300, y: 55 / 300 },
                                            { x: 220 / 300, y: 120 / 300 }, { x: 150 / 300, y: 130 / 300 }]
                                        }, {
                                            type: 'line',
                                            points: [{ x: 150 / 300, y: 130 / 300 }, { x: 95 / 300, y: 130 / 300 }]
                                        }],

                                    },
                                    {
                                        type: 'compound', subStrokes: [{
                                            type: 'line',
                                            points: [{ x: 95 / 300, y: 130 / 300 }, { x: 150 / 300, y: 130 / 300 }]
                                        },
                                        {
                                            type: 'curve',
                                            points: [{ x: 150 / 300, y: 130 / 300 }, { x: 230 / 300, y: 130 / 300 },
                                            { x: 230 / 300, y: 205 / 300 }, { x: 150 / 300, y: 205 / 300 }]
                                        }, {
                                            type: 'line',
                                            points: [{ x: 150 / 300, y: 205 / 300 }, { x: 95 / 300, y: 205 / 300 }]
                                        }],

                                    }
                                ]
                            },
                            'C': {
                                strokes: [
                                    {
                                        type: 'compound', subStrokes: [
                                            {
                                                type: 'curve',
                                                points: [{ x: 210 / 300, y: 90 / 300 }, { x: 180 / 300, y: 20 / 300 },
                                                { x: 90 / 300, y: 50 / 300 }, { x: 90 / 300, y: 130 / 300 }]
                                            }, {
                                                type: 'curve',
                                                points: [{ x: 90 / 300, y: 130 / 300 }, { x: 90 / 300, y: 210 / 300 },
                                                { x: 180 / 300, y: 240 / 300 }, { x: 210 / 300, y: 170 / 300 }]
                                            },],

                                    },
                                ]
                            },
                            'D': {
                                strokes: [
                                    { type: 'line', points: [{ x: 95 / 300, y: 60 / 300 }, { x: 95 / 300, y: 200 / 300 }] },
                                    {
                                        type: 'compound', subStrokes: [
                                            {
                                                type: 'line',
                                                points: [{ x: 95 / 300, y: 60 / 300 }, { x: 150 / 300, y: 60 / 300 }]
                                            }, {
                                                type: 'curve',
                                                points: [{ x: 150 / 300, y: 60 / 300 }, { x: 230 / 300, y: 60 / 300 },
                                                { x: 230 / 300, y: 200 / 300 }, { x: 150 / 300, y: 200 / 300 }]
                                            },
                                            {
                                                type: 'line',
                                                points: [{ x: 150 / 300, y: 200 / 300 }, { x: 95 / 300, y: 200 / 300 }]
                                            }],

                                    }
                                ]
                            },
                            'E': {
                                strokes: [
                                    { type: 'line', points: [{ x: 105 / 300, y: 55 / 300 }, { x: 105 / 300, y: 205 / 300 }] },
                                    { type: 'line', points: [{ x: 105 / 300, y: 55 / 300 }, { x: 205 / 300, y: 55 / 300 }] },
                                    { type: 'line', points: [{ x: 105 / 300, y: 125 / 300 }, { x: 205 / 300, y: 125 / 300 }] },
                                    { type: 'line', points: [{ x: 105 / 300, y: 205 / 300 }, { x: 205 / 300, y: 205 / 300 }] }
                                ]
                            },
                            'F': {
                                strokes: [
                                    { type: 'line', points: [{ x: 110 / 300, y: 55 / 300 }, { x: 110 / 300, y: 205 / 300 }] },
                                    { type: 'line', points: [{ x: 110 / 300, y: 55 / 300 }, { x: 205 / 300, y: 55 / 300 }] },
                                    { type: 'line', points: [{ x: 110 / 300, y: 125 / 300 }, { x: 185 / 300, y: 125 / 300 }] }
                                ]
                            },
                            'G': {
                                strokes: [
                                    {
                                        type: 'compound', subStrokes: [
                                            { type: 'curve', points: [{ x: 210 / 300, y: 90 / 300 }, { x: 195 / 300, y: 35 / 300 }, { x: 85 / 300, y: 35 / 300 }, { x: 85 / 300, y: 130 / 300 }] },
                                            { type: 'curve', points: [{ x: 85 / 300, y: 130 / 300 }, { x: 85 / 300, y: 225 / 300 }, { x: 200 / 300, y: 225 / 300 }, { x: 215 / 300, y: 180 / 300 }] },
                                            { type: 'line', points: [{ x: 215 / 300, y: 180 / 300 }, { x: 215 / 300, y: 140 / 300 }] }
                                        ]
                                    },

                                    { type: 'line', points: [{ x: 165 / 300, y: 140 / 300 }, { x: 215 / 300, y: 140 / 300 }] }
                                ]
                            },
                            'H': {
                                strokes: [
                                    { type: 'line', points: [{ x: 95 / 300, y: 45 / 300 }, { x: 95 / 300, y: 215 / 300 }] },
                                    { type: 'line', points: [{ x: 205 / 300, y: 45 / 300 }, { x: 205 / 300, y: 215 / 300 }] },
                                    { type: 'line', points: [{ x: 95 / 300, y: 125 / 300 }, { x: 205 / 300, y: 125 / 300 }] }
                                ]
                            },
                            'I': {
                                strokes: [
                                    { type: 'line', points: [{ x: 150 / 300, y: 45 / 300 }, { x: 150 / 300, y: 215 / 300 }] },
                                ]
                            },
                            'J': {
                                strokes: [
                                    {
                                        type: 'compound', subStrokes: [
                                            { type: 'line', points: [{ x: 185 / 300, y: 45 / 300 }, { x: 185 / 300, y: 165 / 300 }] },
                                            { type: 'curve', points: [{ x: 185 / 300, y: 165 / 300 }, { x: 185 / 300, y: 225 / 300 }, { x: 105 / 300, y: 225 / 300 }, { x: 100 / 300, y: 165 / 300 }] }
                                        ]
                                    }
                                ]
                            },
                            'K': {
                                strokes: [
                                    { type: 'line', points: [{ x: 95 / 300, y: 45 / 300 }, { x: 95 / 300, y: 215 / 300 }] },
                                    { type: 'line', points: [{ x: 95 / 300, y: 155 / 300 }, { x: 215 / 300, y: 45 / 300 }] },
                                    { type: 'line', points: [{ x: 150 / 300, y: 105 / 300 }, { x: 215 / 300, y: 215 / 300 }] }
                                ]
                            },
                            'L': {
                                strokes: [
                                    { type: 'line', points: [{ x: 110 / 300, y: 45 / 300 }, { x: 110 / 300, y: 205 / 300 }] },
                                    { type: 'line', points: [{ x: 110 / 300, y: 205 / 300 }, { x: 215 / 300, y: 205 / 300 }] }
                                ]
                            },
                            'M': {
                                strokes: [
                                    { type: 'line', points: [{ x: 80 / 300, y: 45 / 300 }, { x: 80 / 300, y: 215 / 300 }] },
                                    { type: 'line', points: [{ x: 220 / 300, y: 45 / 300 }, { x: 220 / 300, y: 215 / 300 }] },
                                    { type: 'line', points: [{ x: 80 / 300, y: 45 / 300 }, { x: 150 / 300, y: 215 / 300 }] },
                                    { type: 'line', points: [{ x: 220 / 300, y: 45 / 300 }, { x: 150 / 300, y: 215 / 300 }] }
                                ]
                            },
                            'N': {
                                strokes: [
                                    { type: 'line', points: [{ x: 95 / 300, y: 45 / 300 }, { x: 95 / 300, y: 215 / 300 }] },
                                    { type: 'line', points: [{ x: 205 / 300, y: 45 / 300 }, { x: 205 / 300, y: 215 / 300 }] },
                                    { type: 'line', points: [{ x: 95 / 300, y: 45 / 300 }, { x: 205 / 300, y: 215 / 300 }] }
                                ]
                            },
                            'O': {
                                strokes: [
                                    {
                                        type: 'compound', subStrokes: [
                                            {
                                                type: 'curve', points: [{ x: 150 / 300, y: 50 / 300 }, { x: 55 / 300, y: 50 / 300 }, { x: 55 / 300, y: 205 / 300 }, { x: 150 / 300, y: 205 / 300 }]
                                            },
                                            {
                                                type: 'curve', points: [{ x: 150 / 300, y: 205 / 300 }, { x: 245 / 300, y: 205 / 300 }, { x: 245 / 300, y: 50 / 300 }, { x: 150 / 300, y: 50 / 300 }]
                                            }

                                        ]
                                    }]
                            },
                            'P': {
                                strokes: [
                                    { type: 'line', points: [{ x: 100 / 300, y: 55 / 300 }, { x: 100 / 300, y: 215 / 300 }] },
                                    {
                                        type: 'compound', subStrokes: [
                                            { type: 'line', points: [{ x: 100 / 300, y: 55 / 300 }, { x: 150 / 300, y: 55 / 300 }] },
                                            {
                                                type: 'curve', points: [{ x: 150 / 300, y: 55 / 300 }, { x: 220 / 300, y: 55 / 300 }, { x: 220 / 300, y: 135 / 300 }, { x: 150 / 300, y: 135 / 300 }]
                                            },
                                            { type: 'line', points: [{ x: 150 / 300, y: 135 / 300 }, { x: 100 / 300, y: 135 / 300 }] }

                                        ]
                                    }
                                ]
                            },
                            'Q': {
                                strokes: [
                                    {
                                        type: 'compound', subStrokes: [
                                            {
                                                type: 'curve', points: [{ x: 150 / 300, y: 50 / 300 }, { x: 55 / 300, y: 50 / 300 }, { x: 55 / 300, y: 205 / 300 }, { x: 150 / 300, y: 205 / 300 }]
                                            },
                                            {
                                                type: 'curve', points: [{ x: 150 / 300, y: 205 / 300 }, { x: 245 / 300, y: 205 / 300 }, { x: 245 / 300, y: 50 / 300 }, { x: 150 / 300, y: 50 / 300 }]
                                            }
                                        ]
                                    },
                                    { type: 'line', points: [{ x: 150 / 300, y: 170 / 300 }, { x: 230 / 300, y: 220 / 300 }] }
                                ]
                            },
                            'R': {
                                strokes: [
                                    { type: 'line', points: [{ x: 100 / 300, y: 55 / 300 }, { x: 100 / 300, y: 215 / 300 }] },
                                    {
                                        type: 'compound', subStrokes: [
                                            { type: 'line', points: [{ x: 100 / 300, y: 55 / 300 }, { x: 150 / 300, y: 55 / 300 }] },
                                            {
                                                type: 'curve', points: [{ x: 150 / 300, y: 55 / 300 }, { x: 220 / 300, y: 55 / 300 }, { x: 220 / 300, y: 135 / 300 }, { x: 150 / 300, y: 135 / 300 }]
                                            },
                                            { type: 'line', points: [{ x: 150 / 300, y: 135 / 300 }, { x: 100 / 300, y: 135 / 300 }] }

                                        ]
                                    },
                                    { type: 'line', points: [{ x: 150 / 300, y: 135 / 300 }, { x: 215 / 300, y: 215 / 300 }] }
                                ]
                            },
                            'S': { // need to fix
                                strokes: [
                                    {
                                        type: 'compound', subStrokes: [
                                            {
                                                type: 'curve', points: [{ x: 200 / 300, y: 90 / 300 }, { x: 195 / 300, y: 40 / 300 }, { x: 100 / 300, y: 40 / 300 }, { x: 100 / 300, y: 90 / 300 }]
                                            },
                                            {
                                                type: 'curve', points: [{ x: 100 / 300, y: 90 / 300 }, { x: 100 / 300, y: 135 / 300 }, { x: 200 / 300, y: 115 / 300 }, { x: 200 / 300, y: 160 / 300 }]
                                            },
                                            {
                                                type: 'curve', points: [{ x: 200 / 300, y: 160 / 300 }, { x: 200 / 300, y: 220 / 300 }, { x: 100 / 300, y: 220 / 300 }, { x: 90 / 300, y: 160 / 300 }]
                                            }
                                        ]
                                    }
                                ]
                            },
                            'T': {
                                strokes: [
                                    { type: 'line', points: [{ x: 80 / 300, y: 55 / 300 }, { x: 220 / 300, y: 55 / 300 }] },
                                    { type: 'line', points: [{ x: 150 / 300, y: 55 / 300 }, { x: 150 / 300, y: 215 / 300 }] }
                                ]
                            },
                            'U': { // need to fix. though looks good for hebrew eyin
                                strokes: [
                                    {
                                        type: 'compound', subStrokes: [
                                            { type: 'line', points: [{ x: 95 / 300, y: 45 / 300 }, { x: 95 / 300, y: 160 / 300 }] },
                                            {
                                                type: 'curve', points: [{ x: 95 / 300, y: 160 / 300 }, { x: 95 / 300, y: 220 / 300 }, { x: 205 / 300, y: 220 / 300 }, { x: 205 / 300, y: 160 / 300 }]
                                            },
                                            { type: 'line', points: [{ x: 205 / 300, y: 160 / 300 }, { x: 205 / 300, y: 45 / 300 }] }
                                        ]
                                    }

                                ]
                            },
                            'V': {
                                strokes: [
                                    { type: 'line', points: [{ x: 90 / 300, y: 45 / 300 }, { x: 150 / 300, y: 200 / 300 }] },
                                    { type: 'line', points: [{ x: 150 / 300, y: 200 / 300 }, { x: 210 / 300, y: 45 / 300 }] }
                                ]
                            },
                            'W': {
                                strokes: [
                                    { type: 'line', points: [{ x: 50 / 300, y: 45 / 300 }, { x: 95 / 300, y: 220 / 300 }] },
                                    { type: 'line', points: [{ x: 95 / 300, y: 220 / 300 }, { x: 150 / 300, y: 45 / 300 }] },
                                    { type: 'line', points: [{ x: 150 / 300, y: 45 / 300 }, { x: 205 / 300, y: 220 / 300 }] },
                                    { type: 'line', points: [{ x: 205 / 300, y: 220 / 300 }, { x: 255 / 300, y: 45 / 300 }] }
                                ]
                            },
                            'X': {
                                strokes: [
                                    { type: 'line', points: [{ x: 95 / 300, y: 45 / 300 }, { x: 205 / 300, y: 220 / 300 }] },
                                    { type: 'line', points: [{ x: 205 / 300, y: 45 / 300 }, { x: 95 / 300, y: 220 / 300 }] }
                                ]
                            },
                            'Y': {
                                strokes: [
                                    { type: 'line', points: [{ x: 90 / 300, y: 45 / 300 }, { x: 150 / 300, y: 130 / 300 }] },
                                    { type: 'line', points: [{ x: 210 / 300, y: 45 / 300 }, { x: 150 / 300, y: 130 / 300 }] },
                                    { type: 'line', points: [{ x: 150 / 300, y: 130 / 300 }, { x: 150 / 300, y: 220 / 300 }] }
                                ]
                            },
                            'Z': {
                                strokes: [
                                    { type: 'line', points: [{ x: 80 / 300, y: 55 / 300 }, { x: 220 / 300, y: 55 / 300 }] },
                                    { type: 'line', points: [{ x: 220 / 300, y: 55 / 300 }, { x: 80 / 300, y: 200 / 300 }] },
                                    { type: 'line', points: [{ x: 80 / 300, y: 200 / 300 }, { x: 220 / 300, y: 200 / 300 }] }
                                ]
                            },
                            'a': {
                                strokes: [
                                    {
                                        type: 'compound',
                                        subStrokes: [
                                            {
                                                type: 'curve',
                                                points: [
                                                    { x: 187.5 / 300, y: 187.5 / 300 }, // Start at "3 o'clock"
                                                    { x: 187.5 / 300, y: 137.5 / 300 },
                                                    { x: 112.5 / 300, y: 137.5 / 300 },
                                                    { x: 112.5 / 300, y: 187.5 / 300 } // End at "9 o'clock"
                                                ]
                                            },
                                            {
                                                type: 'curve',
                                                points: [
                                                    { x: 112.5 / 300, y: 187.5 / 300 },
                                                    { x: 112.5 / 300, y: 237.5 / 300 },
                                                    { x: 187.5 / 300, y: 237.5 / 300 },
                                                    { x: 187.5 / 300, y: 187.5 / 300 }
                                                ]
                                            }
                                        ]
                                    },
                                    { type: 'line', points: [{ x: 187.5 / 300, y: 140 / 300 }, { x: 187.5 / 300, y: 225 / 300 }] }
                                ]
                            },
                            'b': {
                                strokes: [
                                    {
                                        type: 'compound',
                                        subStrokes: [
                                            {
                                                type: 'curve',
                                                points: [
                                                    { x: 150 / 300, y: 112.5 / 300 + 32.5 / 300 }, // Start at "12 o'clock" clockwise
                                                    { x: 200 / 300, y: 112.5 / 300 + 32.5 / 300 },
                                                    { x: 200 / 300, y: 187.5 / 300 + 32.5 / 300 },
                                                    { x: 150 / 300, y: 187.5 / 300 + 32.5 / 300 } // End at "6 o'clock" 220 - 187.5 = 32.5
                                                ]
                                            },
                                            {
                                                type: 'curve',
                                                points: [
                                                    { x: 150 / 300, y: 187.5 / 300 + 32.5 / 300 },
                                                    { x: 100 / 300, y: 187.5 / 300 + 32.5 / 300 },
                                                    { x: 100 / 300, y: 112.5 / 300 + 32.5 / 300 },
                                                    { x: 150 / 300, y: 112.5 / 300 + 32.5 / 300 }
                                                ]
                                            }
                                        ]
                                    },
                                    { type: 'line', points: [{ x: 112.5 / 300, y: 37.5 / 300 + 32.5 / 300 }, { x: 112.5 / 300, y: 187.5 / 300 + 32.5 / 300 }] }

                                    //{ type: 'line', points: [{ x: 1 / 3, y: 1 / 6 }, { x: 1 / 3, y: 5 / 6 }] },
                                    //{ type: 'curve', points: [{ x: 1 / 3, y: 1 / 2 }, { x: 2 / 3, y: 1 / 2 }, { x: 2 / 3, y: 5 / 6 }, { x: 1 / 3, y: 5 / 6 }] }
                                ]
                            },
                            'c': {
                                strokes: [
                                    //{ type: 'curve', points: [{ x: 2 / 3, y: 1 / 2 }, { x: 1 / 3, y: 1 / 2 }, { x: 1 / 3, y: 5 / 6 }, { x: 2 / 3, y: 5 / 6 }] },
                                    //{
                                    //    type: 'curve',
                                    //    points: [
                                    //        { x: 150 / 300, y: 112.5 / 300 + 32.5 / 300 }, // Start at "12 o'clock" clockwise
                                    //        { x: 200 / 300, y: 112.5 / 300 + 32.5 / 300 },
                                    //        { x: 200 / 300, y: 187.5 / 300 + 32.5 / 300 },
                                    //        { x: 150 / 300, y: 187.5 / 300 + 32.5 / 300 } // End at "6 o'clock" 220 - 187.5 = 32.5
                                    //    ]
                                    //},
                                    {
                                        type: 'compound', subStrokes: [
                                            {
                                                type: 'curve', points: [{ x: 195 / 300, y: 130 / 300 }, { x: 170 / 300, y: 75 / 300 }, { x: 110 / 300, y: 100 / 300 }, { x: 110 / 300, y: 150 / 300 }]
                                            },
                                            {
                                                type: 'curve', points: [{ x: 110 / 300, y: 150 / 300 }, { x: 110 / 300, y: 225 / 300 }, { x: 175 / 300, y: 225 / 300 }, { x: 195 / 300, y: 175 / 300 }]
                                            }

                                        ]
                                    }
                                ]
                            },
                            'd': {
                                strokes: [
                                    {
                                        type: 'compound',
                                        subStrokes: [
                                            {
                                                type: 'curve',
                                                points: [
                                                    { x: 150 / 300, y: 112.5 / 300 + 32.5 / 300 }, // Start at "12 o'clock" counterclockwise
                                                    { x: 100 / 300, y: 112.5 / 300 + 32.5 / 300 },
                                                    { x: 100 / 300, y: 187.5 / 300 + 32.5 / 300 },
                                                    { x: 150 / 300, y: 187.5 / 300 + 32.5 / 300 } // End at "6 o'clock" 220 - 187.5 = 32.5
                                                ]
                                            },
                                            {
                                                type: 'curve', points: [
                                                    { x: 150 / 300, y: 187.5 / 300 + 32.5 / 300 }, { x: 200 / 300, y: 187.5 / 300 + 32.5 / 300 },
                                                    { x: 200 / 300, y: 112.5 / 300 + 32.5 / 300 }, { x: 150 / 300, y: 112.5 / 300 + 32.5 / 300 }
                                                ]
                                            }
                                        ]
                                    },
                                    { type: 'line', points: [{ x: 187.5 / 300, y: 37.5 / 300 + 32.5 / 300 }, { x: 187.5 / 300, y: 187.5 / 300 + 32.5 / 300 }] }
                                    //{ type: 'line', points: [{ x: 2 / 3, y: 1 / 6 }, { x: 2 / 3, y: 5 / 6 }] },
                                    //{ type: 'curve', points: [{ x: 2 / 3, y: 1 / 2 }, { x: 1 / 3, y: 1 / 2 }, { x: 1 / 3, y: 5 / 6 }, { x: 2 / 3, y: 5 / 6 }] }
                                ]
                            },
                            'e': {
                                strokes: [
                                    { type: 'line', points: [{ x: 105 / 300, y: 150 / 300 }, { x: 195 / 300, y: 150 / 300 }] },
                                    {
                                        type: 'compound',
                                        subStrokes: [
                                            {
                                                type: 'curve', points: [{ x: 195 / 300, y: 150 / 300 }, { x: 195 / 300, y: 80 / 300 },
                                                { x: 105 / 300, y: 80 / 300 }, { x: 105 / 300, y: 150 / 300 }]
                                            },
                                            {
                                                type: 'curve', points: [{ x: 105 / 300, y: 150 / 300 }, { x: 105 / 300, y: 225 / 300 },
                                                { x: 175 / 300, y: 225 / 300 }, { x: 190 / 300, y: 180 / 300 }]
                                            }
                                        ]
                                    },
                                    //{ type: 'line', points: [{ x: 1 / 3, y: 1 / 2 }, { x: 2 / 3, y: 1 / 2 }] },
                                    //{ type: 'curve', points: [{ x: 2 / 3, y: 1 / 2 }, { x: 1 / 3, y: 1 / 6 }, { x: 1 / 3, y: 5 / 6 }, { x: 2 / 3, y: 5 / 6 }] }
                                    // { type: 'curve', points: [{ x: 2 / 3, y: 1 / 2 }, { x: 2 / 3, y: 1 / 6 }, { x: 1 / 3, y: 1 / 6 }, { x: 1 / 3, y: 5 / 6 }, { x: 2 / 3, y: 5 / 6 }] } five points
                                ]
                            },
                            'f': {
                                strokes: [
                                    {
                                        type: 'compound', subStrokes: [
                                            {
                                                type: 'curve', cA: '#FFA500', cS: '', points: [{ x: 1 / 2, y: 11 / 30 }, { x: 16 / 30, y: 70 / 300 }, { x: 95 / 300, y: 55 / 300 }, { x: 9 / 30, y: 11 / 30 }]
                                            },
                                            { type: 'line', points: [{ x: 9 / 30, y: 11 / 30 }, { x: 9 / 30, y: 22 / 30 }] },
                                        ]
                                    },
                                    {
                                        type: 'line', points: [{ x: 1 / 3, y: 1 / 2 }, { x: 1 / 2, y: 1 / 2 }]
                                    }
                                ]
                            },
                            'g': {
                                strokes: [
                                    {
                                        type: 'compound',
                                        subStrokes: [
                                            {
                                                type: 'curve',
                                                points: [
                                                    { x: 187.5 / 300, y: 187.5 / 300 }, // Start at "3 o'clock" cc
                                                    { x: 187.5 / 300, y: 137.5 / 300 },
                                                    { x: 112.5 / 300, y: 137.5 / 300 },
                                                    { x: 112.5 / 300, y: 187.5 / 300 } // End at "9 o'clock"
                                                ]
                                            },
                                            {
                                                type: 'curve',
                                                points: [
                                                    { x: 112.5 / 300, y: 187.5 / 300 },
                                                    { x: 112.5 / 300, y: 237.5 / 300 },
                                                    { x: 187.5 / 300, y: 237.5 / 300 },
                                                    { x: 187.5 / 300, y: 187.5 / 300 }
                                                ]
                                            }
                                        ]
                                    },
                                    {
                                        type: 'compound',
                                        subStrokes: [
                                            { type: 'line', points: [{ x: 187.5 / 300, y: 137.5 / 300 }, { x: 187.5 / 300, y: 237.5 / 300 }] },
                                            {
                                                type: 'curve',
                                                points: [
                                                    { x: 187.5 / 300, y: 187.5 / 300 + 50 / 300 }, // Start at "3 o'clock" cw
                                                    { x: 187.5 / 300, y: 237.5 / 300 + 50 / 300 },
                                                    { x: 112.5 / 300, y: 237.5 / 300 + 50 / 300 },
                                                    { x: 112.5 / 300, y: 187.5 / 300 + 50 / 300 } // End at "9 o'clock"
                                                ]
                                            }
                                        ]
                                    }
                                    //{ type: 'curve', points: [{ x: 2 / 3, y: 1 / 2 }, { x: 1 / 3, y: 1 / 2 }, { x: 1 / 3, y: 5 / 6 }, { x: 2 / 3, y: 5 / 6 }] },
                                    //{ type: 'line', points: [{ x: 2 / 3, y: 5 / 6 }, { x: 2 / 3, y: 7 / 6 }] }
                                ]
                            },
                            'h': {
                                strokes: [
                                    { type: 'line', points: [{ x: 105 / 300, y: 45 / 300 }, { x: 105 / 300, y: 220 / 300 }] },
                                    {
                                        type: 'compound', subStrokes: [
                                            {
                                                type: 'curve', points: [{ x: 105 / 300, y: 145 / 300 }, { x: 105 / 300, y: 110 / 300 }, { x: 190 / 300, y: 70 / 300 }, { x: 190 / 300, y: 130 / 300 }]

                                            },
                                            { type: 'line', points: [{ x: 190 / 300, y: 130 / 300 }, { x: 190 / 300, y: 220 / 300 }] }
                                        ]
                                    }
                                ]
                            },
                            'i': {
                                strokes: [
                                    { type: 'line', points: [{ x: 150 / 300, y: 130 / 300 }, { x: 150 / 300, y: 220 / 300 }] },
                                    {
                                        type: 'compound',
                                        subStrokes: [
                                            {
                                                type: 'curve',
                                                points: [{ x: 165 / 300, y: 80 / 300 }, { x: 165 / 300, y: 60 / 300 },
                                                { x: 135 / 300, y: 60 / 300 }, { x: 135 / 300, y: 80 / 300 }],
                                                arrowStyle: {
                                                    headLength: 10 / 300,
                                                    headWidth: 7.5 / 300
                                                }
                                            },
                                            {
                                                type: 'curve',
                                                points: [
                                                    { x: 135 / 300, y: 80 / 300 }, { x: 135 / 300, y: 100 / 300 },
                                                    { x: 165 / 300, y: 100 / 300 }, { x: 165 / 300, y: 80 / 300 }],
                                                arrowStyle: {
                                                    headLength: 10 / 300,
                                                    headWidth: 7.5 / 300
                                                }
                                            }
                                        ]
                                    }
                                ]
                            },
                            'j': {
                                strokes: [
                                    {
                                        type: 'compound',
                                        subStrokes: [
                                            { type: 'line', points: [{ x: 150 / 300, y: 130 / 300 }, { x: 150 / 300, y: 200 / 300 }] },
                                            {
                                                type: 'curve',
                                                points: [{ x: 150 / 300, y: 200 / 300 }, { x: 150 / 300, y: 250 / 300 }, { x: 130 / 300, y: 270 / 300 }, { x: 90 / 300, y: 250 / 300 }]

                                            }
                                        ]
                                    },
                                    {
                                        type: 'compound',
                                        subStrokes: [
                                            {
                                                type: 'curve',
                                                points: [{ x: 165 / 300, y: 80 / 300 }, { x: 165 / 300, y: 60 / 300 },
                                                { x: 135 / 300, y: 60 / 300 }, { x: 135 / 300, y: 80 / 300 }],
                                                arrowStyle: {
                                                    headLength: 10 / 300,
                                                    headWidth: 7.5 / 300
                                                }
                                            },
                                            {
                                                type: 'curve',
                                                points: [
                                                    { x: 135 / 300, y: 80 / 300 }, { x: 135 / 300, y: 100 / 300 },
                                                    { x: 165 / 300, y: 100 / 300 }, { x: 165 / 300, y: 80 / 300 }],
                                                arrowStyle: {
                                                    headLength: 10 / 300,
                                                    headWidth: 7.5 / 300
                                                }
                                            }
                                        ]
                                    }
                                ]
                            },
                            'k': {
                                strokes: [
                                    { type: 'line', points: [{ x: 115 / 300, y: 40 / 300 }, { x: 115 / 300, y: 220 / 300 }] },
                                    { type: 'line', points: [{ x: 115 / 300, y: 170 / 300 }, { x: 190 / 300, y: 90 / 300 }] },
                                    { type: 'line', points: [{ x: 150 / 300, y: 135 / 300 }, { x: 200 / 300, y: 220 / 300 }] }
                                ]
                            },
                            'l': {
                                strokes: [
                                    { type: 'line', points: [{ x: 150 / 300, y: 40 / 300 }, { x: 150 / 300, y: 220 / 300 }] }
                                ]
                            },
                            'm': {
                                strokes: [
                                    { type: 'line', points: [{ x: 70 / 300, y: 90 / 300 }, { x: 70 / 300, y: 220 / 300 }] },
                                    {
                                        type: 'compound', subStrokes: [
                                            { type: 'curve', points: [{ x: 70 / 300, y: 150 / 300 }, { x: 70 / 300, y: 110 / 300 }, { x: 150 / 300, y: 65 / 300 }, { x: 150 / 300, y: 145 / 300 }] },
                                            { type: 'line', points: [{ x: 150 / 300, y: 140 / 300 }, { x: 150 / 300, y: 220 / 300 }] }
                                        ]
                                    },
                                    {
                                        type: 'compound', subStrokes: [
                                            { type: 'curve', points: [{ x: 150 / 300, y: 150 / 300 }, { x: 150 / 300, y: 100 / 300 }, { x: 230 / 300, y: 70 / 300 }, { x: 230 / 300, y: 150 / 300 }] },
                                            { type: 'line', points: [{ x: 230 / 300, y: 140 / 300 }, { x: 230 / 300, y: 220 / 300 }] }
                                        ]
                                    },

                                ]
                            },
                            'n': {
                                strokes: [
                                    { type: 'line', points: [{ x: 105 / 300, y: 90 / 300 }, { x: 105 / 300, y: 220 / 300 }] },
                                    {
                                        type: 'compound', subStrokes: [
                                            { type: 'curve', points: [{ x: 105 / 300, y: 150 / 300 }, { x: 105 / 300, y: 110 / 300 }, { x: 190 / 300, y: 65 / 300 }, { x: 190 / 300, y: 140 / 300 }] },
                                            { type: 'line', points: [{ x: 190 / 300, y: 140 / 300 }, { x: 190 / 300, y: 220 / 300 }] }
                                        ]
                                    },
                                ]
                            },
                            'o': {
                                strokes: [
                                    {
                                        type: 'compound',
                                        subStrokes: [
                                            {
                                                type: 'curve',
                                                points: [
                                                    { x: 187.5 / 300, y: 187.5 / 300 }, // Start at "3 o'clock"
                                                    { x: 187.5 / 300, y: 137.5 / 300 },
                                                    { x: 112.5 / 300, y: 137.5 / 300 },
                                                    { x: 112.5 / 300, y: 187.5 / 300 } // End at "9 o'clock"
                                                ]
                                            },
                                            {
                                                type: 'curve',
                                                points: [
                                                    { x: 112.5 / 300, y: 187.5 / 300 },
                                                    { x: 112.5 / 300, y: 237.5 / 300 },
                                                    { x: 187.5 / 300, y: 237.5 / 300 },
                                                    { x: 187.5 / 300, y: 187.5 / 300 }
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            },
                            'p': {
                                strokes: [
                                    {
                                        type: 'compound',
                                        subStrokes: [
                                            {
                                                type: 'curve',
                                                points: [
                                                    { x: 187.5 / 300, y: 187.5 / 300 }, // Start at "3 o'clock"
                                                    { x: 187.5 / 300, y: 137.5 / 300 },
                                                    { x: 112.5 / 300, y: 137.5 / 300 },
                                                    { x: 112.5 / 300, y: 187.5 / 300 } // End at "9 o'clock"
                                                ]
                                            },
                                            {
                                                type: 'curve',
                                                points: [
                                                    { x: 112.5 / 300, y: 187.5 / 300 },
                                                    { x: 112.5 / 300, y: 237.5 / 300 },
                                                    { x: 187.5 / 300, y: 237.5 / 300 },
                                                    { x: 187.5 / 300, y: 187.5 / 300 }
                                                ]
                                            }
                                        ]
                                    },
                                    { type: 'line', points: [{ x: 112.5 / 300, y: 145 / 300 }, { x: 112.5 / 300, y: 270 / 300 }] },

                                ]
                            },
                            'q': {
                                strokes: [{
                                    type: 'compound',
                                    subStrokes: [
                                        {
                                            type: 'curve',
                                            points: [
                                                { x: 187.5 / 300, y: 187.5 / 300 }, // Start at "3 o'clock"
                                                { x: 187.5 / 300, y: 137.5 / 300 },
                                                { x: 112.5 / 300, y: 137.5 / 300 },
                                                { x: 112.5 / 300, y: 187.5 / 300 } // End at "9 o'clock"
                                            ]
                                        },
                                        {
                                            type: 'curve',
                                            points: [
                                                { x: 112.5 / 300, y: 187.5 / 300 },
                                                { x: 112.5 / 300, y: 237.5 / 300 },
                                                { x: 187.5 / 300, y: 237.5 / 300 },
                                                { x: 187.5 / 300, y: 187.5 / 300 }
                                            ]
                                        }
                                    ]
                                },
                                // give curved end?
                                { type: 'line', points: [{ x: 187.5 / 300, y: 145 / 300 }, { x: 187.5 / 300, y: 270 / 300 }] },
                                ]
                            },
                            'r': {
                                strokes: [
                                    { type: 'line', points: [{ x: 135 / 300, y: 90 / 300 }, { x: 135 / 300, y: 220 / 300 }] },
                                    {
                                        type: 'curve',
                                        points: [{ x: 135 / 300, y: 140 / 300 }, { x: 135 / 300, y: 115 / 300 }, { x: 170 / 300, y: 85 / 300 }, { x: 195 / 300, y: 110 / 300 }]
                                    }
                                ]
                            },
                            's': {
                                strokes: [
                                    {
                                        type: 'compound',
                                        subStrokes: [
                                            {
                                                type: 'curve',
                                                points: [{ x: 187.5 / 300, y: 120 / 300 }, { x: 175 / 300, y: 90 / 300 }, { x: 110 / 300, y: 90 / 300 }, { x: 110 / 300, y: 125 / 300 }]
                                            },
                                            {
                                                type: 'curve',
                                                points: [{ x: 110 / 300, y: 125 / 300 }, { x: 110 / 300, y: 165 / 300 }, { x: 190 / 300, y: 140 / 300 }, { x: 190 / 300, y: 180 / 300 }]

                                            },
                                            {
                                                type: 'curve',
                                                points: [{ x: 190 / 300, y: 180 / 300 }, { x: 190 / 300, y: 225 / 300 }, { x: 110 / 300, y: 220 / 300 }, { x: 105 / 300, y: 180 / 300 }]
                                            }
                                        ]
                                    }
                                ]
                            },
                            't': {
                                strokes: [
                                    {
                                        type: 'compound', subStrokes: [
                                            { type: 'line', points: [{ x: 147.5 / 300, y: 45 / 300 }, { x: 147.5 / 300, y: 170 / 300 }] },
                                            {
                                                type: 'curve', points: [{ x: 147.5 / 300, y: 170 / 300 }, { x: 147.5 / 300, y: 205 / 300 }, { x: 160 / 300, y: 215 / 300 }, { x: 190 / 300, y: 205 / 300 }]
                                            }
                                        ]
                                    },
                                    { type: 'line', points: [{ x: 112.5 / 300, y: 100 / 300 }, { x: 182.5 / 300, y:  100/ 300 }] },
                                    
                                ]
                            },
                            'u': {
                                strokes: [
                                    {
                                        type: 'compound', subStrokes: [
                                            { type: 'line', points: [{ x: 110 / 300, y: 90 / 300 }, { x: 110 / 300, y: 170 / 300 }] },
                                            {
                                                type: 'curve', points: [{ x: 110 / 300, y: 170 / 300 }, { x: 110 / 300, y: 220 / 300 }, { x: 190 / 300, y: 220 / 300 }, { x: 190 / 300, y: 170 / 300 }]
                                            }
                                        ]
                                    },
                                    { type: 'line', points: [{ x: 190 / 300, y: 90 / 300 }, { x: 190 / 300, y: 215 / 300 }] }
                                ]
                            },
                            'v': {// resume here
                                strokes: [
                                    { type: 'line', points: [{ x: 100 / 300, y: 90 / 300 }, { x: 150 / 300, y: 220 / 300 }] },
                                    { type: 'line', points: [{ x: 150 / 300, y: 220 / 300 }, { x: 200 / 300, y: 90 / 300 }] }
                                ]
                            },
                            'w': {
                                strokes: [
                                    { type: 'line', points: [{ x: 70 / 300, y: 90 / 300 }, { x: 110 / 300, y: 220 / 300 }] },
                                    { type: 'line', points: [{ x: 110 / 300, y: 220 / 300 }, { x: 150 / 300, y: 90 / 300 }] },
                                    { type: 'line', points: [{ x: 150 / 300, y: 90 / 300 }, { x: 190 / 300, y: 220 / 300 }] },
                                    { type: 'line', points: [{ x: 190 / 300, y: 220 / 300 }, { x: 230 / 300, y: 90 / 300 }] }
                                ]
                            },
                            'x': {
                                strokes: [
                                    { type: 'line', points: [{ x: 190 / 300, y: 90 / 300 }, { x: 190 / 300, y: 215 / 300 }] },
                                    { type: 'line', points: [{ x: 190 / 300, y: 90 / 300 }, { x: 190 / 300, y: 215 / 300 }] }
                                ]
                            },
                            'y': {
                                strokes: [
                                    { type: 'line', points: [{ x: 100 / 300, y: 90 / 300 }, { x: 150 / 300, y: 220 / 300 }] },
                                    {
                                        type: 'compound', subStrokes: [
                                            { type: 'line', points: [{ x: 200 / 300, y: 90 / 300 }, { x: 150 / 300, y: 220 / 300 }] },
                                            {
                                                type: 'curve', points: [{ x: 150 / 300, y: 220 / 300 }, { x: 130 / 300, y: 270 / 300 }, { x: 110 / 300, y: 260 / 300 }, { x: 90 / 300, y: 255 / 300 }]
                                            }
                                        ]
                                    },
                                ]
                            },
                            'z': {
                                strokes: [
                                    { type: 'line', points: [{ x: 100 / 300, y: 100 / 300 }, { x: 200 / 300, y: 100 / 300 }] },
                                    { type: 'line', points: [{ x: 200 / 300, y: 100 / 300 }, { x: 100 / 300, y: 205 / 300 }] },
                                    { type: 'line', points: [{ x: 100 / 300, y: 205 / 300 }, { x: 200 / 300, y: 205 / 300 }] }
                                ]
                            },
                        };

                        // Useful reusable sequences
                        // 3 oclock starting circle small inline
                        /* {
                            type: 'curve',
                                points: [
                                    { x: 187.5 / 300, y: 187.5 / 300 }, // Start at "3 o'clock"
                                    { x: 187.5 / 300, y: 137.5 / 300 },
                                    { x: 112.5 / 300, y: 137.5 / 300 },
                                    { x: 112.5 / 300, y: 187.5 / 300 } // End at "9 o'clock"
                                ]
                        },
                        { type: 'curve', points: [
                                    { x: 112.5 / 300, y: 187.5 / 300 }, { x: 112.5 / 300, y: 237.5 / 300 },
                                    { x: 187.5 / 300, y: 237.5 / 300 }, { x: 187.5 / 300, y: 187.5 / 300 } ] } */

                        // 3 oclock starting circle large centered
                        /* {
                            type: 'curve',
                            points: [
                                { x: 225 / 300, y: 150 / 300 }, // Start at "3 o'clock"
                                { x: 225 / 300, y: 55 / 300 },
                                { x: 75 / 300, y: 55 / 300 },
                                { x: 75 / 300, y: 150 / 300 } // End at "12 o'clock"
                            ]
                        },
                        {
                            type: 'curve',
                            points: [
                                { x: 75 / 300, y: 150 / 300 }, { x: 75 / 300, y: 245 / 300 },
                                { x: 225 / 300, y: 245 / 300 }, { x: 225 / 300, y: 150 / 300 }] }*/
                        console.log("using data from page. all good");
                    }


                    if ("ok" in response && !response.ok) {
                        // Fall back to English if language-specific data not available
                        const fallbackResponse = await fetch('./data/letters-en.json');
                        return await fallbackResponse.json();
                    }
                    if ("ok" in response) return await response.json();
                    return response;
                } catch (error) {
                    console.error('Error loading letter data:', error);
                    // Return empty letter data as fallback
                    return {};
                }
            }
        }

        // --- Utils Module ---
        const Utils = {
            /**
             * Scale a normalized value to actual pixels
             */
            scaleToCanvas(value, config, dimension = 'width') {
                return value * config.canvas[dimension];
            },

            /**
               * Calculate distance between two points
               */
            distance(point1, point2) {
                return Math.hypot(point2.x - point1.x, point2.y - point1.y);
            },

            /**
             * Interpolate between points
             */
            lerp(a, b, t) {
                return a + (b - a) * t;
            },

            /**
             * Convert an event to canvas coordinates return a new point
             */
            getEventPoint(event, config) {
                // Implementation
                let x = event.offsetX;
                let y = event.offsetY;
                return new Point(x, y, config, normalized = false);
            },

            /**
             * Calculates the control points and end point for a partial cubic Bézier curve.
             * This utility implements de Casteljau's algorithm to compute a Bézier curve at a specific progress value.
             *
             * The function can be called in three different ways:
             * 1. With a stroke object: calculatePartialBezier(t, stroke)
             * 2. With point objects: calculatePartialBezier(t, p0, p1, p2, p3)
             * 3. With individual coordinates: calculatePartialBezier(t, x1, y1, cx1, cy1, cx2, cy2, x2, y2)
             *
             * @param {number} t - Progress along the curve from 0 to 1.
             *                     0 corresponds to the start point, 1 corresponds to the end point.
             * @param {Object|number} arg1 - Either a stroke object with points array,
             *                               a Point object representing start point,
             *                               or the x-coordinate of start point (x1).
             * @param {Object|number} [arg2] - Either a Point object representing first control point,
             *                                or the y-coordinate of start point (y1).
             * @param {Object|number} [arg3] - Either a Point object representing second control point,
             *                                or the x-coordinate of first control point (cx1).
             * @param {Object|number} [arg4] - Either a Point object representing end point,
             *                                or the y-coordinate of first control point (cy1).
             * @param {number} [arg5] - The x-coordinate of second control point (cx2).
             * @param {number} [arg6] - The y-coordinate of second control point (cy2).
             * @param {number} [arg7] - The x-coordinate of end point (x2).
             * @param {number} [arg8] - The y-coordinate of end point (y2).
             *
             * @returns {Object} An object containing control points for the partial Bézier curve:
             *   @returns {number} newCx1 - x-coordinate of first control point
             *   @returns {number} newCy1 - y-coordinate of first control point
             *   @returns {number} newCx2 - x-coordinate of second control point
             *   @returns {number} newCy2 - y-coordinate of second control point
             *   @returns {number} newX2 - x-coordinate of end point
             *   @returns {number} newY2 - y-coordinate of end point
             *   @returns {Object} controlPoint1 - Object with {x,y} coordinates of first control point
             *   @returns {Object} controlPoint2 - Object with {x,y} coordinates of second control point
             *   @returns {Object} endPoint - Object with {x,y} coordinates of end point
             *
             * @throws {Error} If a stroke object is provided but doesn't contain exactly 4 points
             *
             * @example
             * // Usage with a stroke object
             * const stroke = { points: [{x:0,y:0}, {x:50,y:20}, {x:80,y:20}, {x:100,y:0}] };
             * const partial = Utils.calculatePartialBezier(0.5, stroke);
             *
             * @example
             * // Usage with point objects
             * const partial = Utils.calculatePartialBezier(0.5,
             *   {x:0,y:0}, {x:50,y:20}, {x:80,y:20}, {x:100,y:0});
             *
             * @example
             * // Usage with individual coordinates
             * const partial = Utils.calculatePartialBezier(0.5, 0,0, 50,20, 80,20, 100,0);
             */
            calculatePartialBezier(t, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
                let x1, y1, cx1, cy1, cx2, cy2, x2, y2;

                // Check argument types to determine the calling pattern
                if (typeof arg1 === 'object' && arg1 !== null) {
                    if (arg1 instanceof CurveStroke || arg1.constructor.name === 'CurveStroke') {
                        // It's a CurveStroke object
                        const points = arg1.points;
                        if (points.length !== 4) {
                            throw new Error('Bezier curve requires exactly 4 control points');
                        }

                        x1 = points[0].x;
                        y1 = points[0].y;
                        cx1 = points[1].x;
                        cy1 = points[1].y;
                        cx2 = points[2].x;
                        cy2 = points[2].y;
                        x2 = points[3].x;
                        y2 = points[3].y;
                    } else if (Array.isArray(arg1) && arg1.length === 4 && 'x' in arg1[0]) {
                        // It's an array of points
                        x1 = arg1[0].x;
                        y1 = arg1[0].y;
                        cx1 = arg1[1].x;
                        cy1 = arg1[1].y;
                        cx2 = arg1[2].x;
                        cy2 = arg1[2].y;
                        x2 = arg1[3].x;
                        y2 = arg1[3].y;
                    } else if ('x' in arg1 && 'y' in arg1 && 'x' in arg2 && 'y' in arg2 &&
                        'x' in arg3 && 'y' in arg3 && 'x' in arg4 && 'y' in arg4) {
                        // It's 4 point objects
                        x1 = arg1.x;
                        y1 = arg1.y;
                        cx1 = arg2.x;
                        cy1 = arg2.y;
                        cx2 = arg3.x;
                        cy2 = arg3.y;
                        x2 = arg4.x;
                        y2 = arg4.y;
                    }
                } else {
                    // Individual coordinates
                    x1 = arg1;
                    y1 = arg2;
                    cx1 = arg3;
                    cy1 = arg4;
                    cx2 = arg5;
                    cy2 = arg6;
                    x2 = arg7;
                    y2 = arg8;
                }

                // Linear interpolation function
                const lerp = (a, b, t) => a + (b - a) * t;

                // Calculate intermediate points using de Casteljau's algorithm
                const x12 = lerp(x1, cx1, t), y12 = lerp(y1, cy1, t);
                const x23 = lerp(cx1, cx2, t), y23 = lerp(cy1, cy2, t);
                const x34 = lerp(cx2, x2, t), y34 = lerp(cy2, y2, t);

                const x123 = lerp(x12, x23, t), y123 = lerp(y12, y23, t);
                const x234 = lerp(x23, x34, t), y234 = lerp(y23, y34, t);

                const x1234 = lerp(x123, x234, t), y1234 = lerp(y123, y234, t);

                // Return the control points for the partial curve
                return {
                    // Points as separate coordinates
                    newCx1: x12, newCy1: y12,
                    newCx2: x123, newCy2: y123,
                    newX2: x1234, newY2: y1234,

                    // Points as objects for easier use in some contexts
                    controlPoint1: { x: x12, y: y12 },
                    controlPoint2: { x: x123, y: y123 },
                    endPoint: { x: x1234, y: y1234 }
                };
            },
            /**
             * Find a point along a path at a specific percentage of the total path length
             * @param {Point[]} userPath - Array of points representing the user's drawing path
             * @param {Object} pUserPath - Processed path data from processPath method
             * @param {number} t - Interpolation value between 0 and 1 representing position along the path
             * @returns {Point} The interpolated point at the specified position
             */
            interpolatePathPoint(userPath, pUserPath, t) {
                // Handle edge cases
                if (!userPath || userPath.length < 2) {
                    return null;
                }

                // If pUserPath wasn't provided, calculate it
                if (!pUserPath) {
                    pUserPath = this.processPath(userPath);
                }

                // Early returns for start and end points
                if (t <= 0 || pUserPath.totalLength == 0) return userPath[0];
                if (t >= 1) return userPath[userPath.length - 1];

                // Find the appropriate segment based on the cumulative lengths
                const cumulativeLengths = pUserPath.cumulativeLengths;
                let segmentIndex = 0;

                for (let i = 0; i < cumulativeLengths.length; i++) {
                    if (t <= cumulativeLengths[i]) {
                        segmentIndex = i;
                        break;
                    }
                }

                // Calculate the local interpolation factor within the segment
                const prevCumulativeLength = segmentIndex > 0 ? cumulativeLengths[segmentIndex - 1] : 0;
                const segmentLength = cumulativeLengths[segmentIndex] - prevCumulativeLength;

                // Avoid division by zero
                if (segmentLength === 0) {
                    return userPath[segmentIndex];
                }

                // Calculate local t within the segment
                const localT = (t - prevCumulativeLength) / segmentLength;

                // Perform the interpolation between the points in this segment
                const p0 = userPath[segmentIndex];
                const p1 = userPath[segmentIndex + 1];

                // Use Point's lerp method or manually interpolate
                if (p0.lerp) {
                    let r = p0.lerp(p1, localT);
                    return r
                } else {
                    // Manual interpolation if lerp method isn't available
                    let r = new Point(
                        this.lerp(p0.x, p1.x, localT),
                        this.lerp(p0.y, p1.y, localT),
                        p0.config,
                        false // Not normalized
                    );
                    console.log(r);
                    return
                }
            },
            /**
             * Calculates the total and relative lengths of a path.
             * Takes an array of points from a user-drawn path and returns the total length
             * and the relative lengths of each segment as a proportion of the total length.
             *
             * @param {Point[]} path - An array of points representing the user-drawn path.
             * @returns {Object} An object containing the total length in pixels and relative lengths of path segments.
             */
            processPath(path) {
                if (!path || path.length < 2) {
                    return { totalLength: 0, relativeLengths: [], cumulativeLengths: [] };
                }

                // Calculate length of each segment
                const segmentLengths = [];
                let totalLength = 0;

                for (let i = 1; i < path.length; i++) {
                    const length = path[i - 1].distanceTo(path[i]);
                    segmentLengths.push(length);
                    totalLength += length;
                }

                // Calculate relative lengths (proportion of total)
                const relativeLengths = segmentLengths.map(length => length / totalLength);

                // Calculate cumulative lengths (for interpolation)
                const cumulativeLengths = [];
                let cumulativeLength = 0;

                for (const length of segmentLengths) {
                    cumulativeLength += length;
                    cumulativeLengths.push(cumulativeLength / totalLength);
                }

                return {
                    totalLength,        // Total path length in pixels
                    segmentLengths,     // Length of each segment
                    relativeLengths,    // Proportion of each segment to total length
                    cumulativeLengths   // Cumulative proportion at each point
                };
            },
            /**
             * Merges two style objects together, with sourceStyle properties overriding targetStyle
             * Handles both shallow (top-level) and deep (nested) properties
             * Special handling for normalized dimension values
             * 
             * @param {Object} targetStyle - The base style object to merge into
             * @param {Object} sourceStyle - The style object whose properties take precedence
             * @param {boolean} [deepMerge=true] - Whether to recursively merge nested objects
             * @returns {Object} A new object with merged style properties
             */
            mergeStyles(targetStyle, sourceStyle, deepMerge = true) {
                    // If either input is null/undefined, return the other one
                    if (!targetStyle) return sourceStyle ? { ...sourceStyle } : {};
                    if (!sourceStyle) return { ...targetStyle };

                    // Start with a copy of the target style
                    const result = { ...targetStyle };

                    // Iterate through source style properties
                    Object.keys(sourceStyle).forEach(key => {
                        const sourceValue = sourceStyle[key];
                        // where strokestyle has getters
                        if (key == 'lineWidth' || key == 'headLength' || key == 'headWidth') { result['_' + key] = sourceValue; }

                        // Handle nested objects with deep merge
                        if (deepMerge &&
                            typeof sourceValue === 'object' &&
                            sourceValue !== null &&
                            !Array.isArray(sourceValue) &&
                            typeof result[key] === 'object' &&
                            result[key] !== null &&
                            !Array.isArray(result[key])) {

                            // Recursively merge nested objects
                            result[key] = mergeStyles(result[key], sourceValue, true);
                        }
                        // For arrays, replace completely (don't try to merge arrays)
                        else if (Array.isArray(sourceValue)) {
                            result[key] = [...sourceValue];
                        }
                        // For regular properties, overwrite with source value
                        else {
                            result[key] = sourceValue;
                        }
                    });

                    return result;
            }
        };

        // --- Models ---
        /**
         * Point class representing coordinates in the drawing system.
         * Can work with both normalized (0-1 range) and absolute pixel coordinates.
         */
        class Point {
            /**
             * Create a new point
             * @param {number} x - The x coordinate
             * @param {number} y - The y coordinate
             * @param {object} config - The app configuration obj
             * @param {boolean} normalized - Whether coordinates are normalized (0-1 range) or absolute pixels
             */
            constructor(x, y, config, normalized = true) {
                this._x = x;
                this._y = y;
                this.config = config;
                this.normalized = normalized;
            }

            /**
             * Get the x coordinate in pixels
             * @return {number} The x coordinate in pixels
             */
            get x() {
                // console.log(this.config);
                return this.normalized ?
                    Utils.scaleToCanvas(this._x, this.config, 'width') :
                    this._x;
            }

            /**
             * Get the y coordinate in pixels
             * @return {number} The y coordinate in pixels
             */
            get y() {
                return this.normalized ?
                    Utils.scaleToCanvas(this._y, this.config, 'height') :
                    this._y;
            }

            /**
             * Get the raw x value (without scaling)
             * @return {number} The raw x value
             */
            get rawX() {
                return this._x;
            }

            /**
             * Get the raw y value (without scaling)
             * @return {number} The raw y value
             */
            get rawY() {
                return this._y;
            }

            /**
             * Set the x coordinate
             * @param {number} value - The new x value. in Coords
             */
            set x(value) {
                this._x = this.normalized ?
                    value / this.config.canvas.width :
                    value;
            }

            /**
             * Set the y coordinate
             * @param {number} value - The new y value
             */
            set y(value) {
                this._y = this.normalized ?
                    value / this.config.canvas.height :
                    value;
            }

            /**
             * Calculate distance to another point
             * @param {Point} point - The target point
             * @return {number} Distance in pixels
             */
            distanceTo(point) {
                return Math.hypot(this.x - point.x, this.y - point.y);
            }

            /**
             * Create a new point interpolated between this point and target
             * @param {Point} target - The target point
             * @param {number} t - Interpolation factor (0-1)
             * @return {Point} The interpolated point
             */
            lerp(target, t) {
                return new Point(
                    this.x + (target.x - this.x) * t,
                    this.y + (target.y - this.y) * t,
                    this.config,
                    false
                );
            }

            /**
             * Convert to a different normalization state
             * @param {boolean} normalized - The target normalization state
             * @return {Point} A new point with the requested normalization
             */
            toNormalization(normalized) {
                if (this.normalized === normalized) {
                    return new Point(this._x, this._y, this.config, normalized);
                }

                if (normalized) {
                    // Convert absolute to normalized
                    return new Point(
                        this._x / this.config.canvas.width,
                        this._y / this.config.canvas.height,
                        this.config,
                        true
                    );
                } else {
                    // Convert normalized to absolute
                    return new Point(
                        this._x * this.config.canvas.width,
                        this._y * this.config.canvas.height,
                        this.config,
                        false
                    );
                }
            }

            /**
             * Create a clone of this point
             * @return {Point} A new point with the same values
             */
            clone() {
                return new Point(this._x, this._y, this.config, this.normalized);
            }

            /**
             * Convert to an object for serialization
             * @param {boolean} normalized - Whether to return normalized values
             * @return {Object} An object with x and y properties
             */
            toObject(normalized = this.normalized) {
                if (normalized) {
                    return { x: this._x, y: this._y };
                } else {
                    return { x: this.x, y: this.y };
                }
            }

            /**
             * Create a Point from an object
             * @param {Object} obj - The object with x and y properties
             * @param {boolean} normalized - Whether obj contains normalized values
             * @return {Point} A new point instance
             */
            static fromObject(obj, config, normalized = true) {
                return new Point(obj.x, obj.y, config, normalized);
            }

            /**
             * Create a Point from an event relative to a canvas
             * @param {MouseEvent|TouchEvent} event - The event
             * @param {HTMLCanvasElement} canvas - The canvas element
             * @param {boolean} normalized - Whether to return normalized coordinates
             * @return {Point} A new Point instance
             */
            static fromEvent(event, canvas, config, normalized = true) {
                const rect = canvas.getBoundingClientRect();
                const point = event.touches ? event.touches[0] : event;

                const x = point.clientX - rect.left;
                const y = point.clientY - rect.top;

                // Create a Point with absolute coordinates, then convert if needed
                const absolutePoint = new Point(x, y, config, false);
                return normalized ? absolutePoint.toNormalization(true) : absolutePoint;
            }
        }

        /**
        * StrokeStyle: Style class for stroke rendering with normalized dimensions.
        * Automatically scales dimension properties based on canvas size.
        * No longer using Proxy (simplified to getter functions).
        */
        class StrokeStyle {
            /**
             * Create a new stroke style
             * @param {Object} options - Style configuration options
             * @param {string} options.color - Stroke color (CSS color string)
             * @param {number} options.lineWidth - Line width (will be scaled if normalized)
             * @param {string} options.lineCap - Line cap style ('butt', 'round', 'square')
             * @param {boolean} options.normalized - Whether dimensions should be automatically scaled
             * @param {number} options.opacity - Stroke opacity (0-1)
             * @param {Array} options.lineDash - Line dash pattern
             * @param {Object} config - App configuration containing canvas dimensions
             */
            constructor(options, config) {
                // Store the canvas configuration for scaling
                this.config = config;

                // Required properties
                this.color = options.color || '#000000';
                this._lineWidth = options.lineWidth || 3/300;
                this.lineCap = options.lineCap || 'round';

                // Optional properties
                this.opacity = options.hasOwnProperty('opacity') ? options.opacity : 1;
                this.lineDash = options.lineDash || [];

                // For specialized stroke types
                this._headLength = options.headLength || 1 / 300;
                this._headWidth = options.headWidth || 5 / 300;
                this.shadowBlur = options.shadowBlur || 0;
                this.shadowColor = options.shadowColor || this.color;

                // For animation effects
                this.animatable = options.hasOwnProperty('animatable') ? options.animatable : false;
                this.pulsate = options.hasOwnProperty('pulsate') ? options.pulsate : false;
            }

            /**
             * Apply this style to a canvas context
             * @param {CanvasRenderingContext2D} ctx - The canvas context to apply styles to
             */
            apply(ctx) {
                // Save the previous context state
                ctx.save();

                // Apply basic styles
                ctx.strokeStyle = this.color;
                ctx.lineWidth = this.lineWidth;
                ctx.lineCap = this.lineCap;
                ctx.globalAlpha = this.opacity;

                // Apply line dash if specified
                if (this.lineDash.length > 0) {
                    ctx.setLineDash(this.normalized ?
                        this.lineDash.map(v => v * this.config.canvas.width) :
                        this.lineDash);
                } else {
                    ctx.setLineDash([]);
                }

                // Apply shadow if specified
                if (this.shadowBlur > 0) {
                    ctx.shadowBlur = this.normalized ?
                        this.shadowBlur * this.config.canvas.width :
                        this.shadowBlur;
                    ctx.shadowColor = this.shadowColor;
                }

                return ctx;
            }

            /**
             * Restore the context to its previous state
             * @param {CanvasRenderingContext2D} ctx - The canvas context to restore
             */
            restore(ctx) {
                ctx.restore();
            }
            /**
               * Create a copy of this style
               * @returns {StrokeStyle} - A new StrokeStyle instance with the same properties
               */
            clone() {
                return new StrokeStyle({
                    color: this.color,
                    lineWidth: this._lineWidth,
                    lineCap: this.lineCap,
                    normalized: this.normalized,
                    opacity: this.opacity,
                    lineDash: [...this.lineDash],
                    headLength: this.headLength,
                    headWidth: this.headWidth,
                    shadowBlur: this.shadowBlur,
                    shadowColor: this.shadowColor,
                    animatable: this.animatable,
                    pulsate: this.pulsate
                }, this.config);
            }
            /**
             * Create a modified version of this style
             * @param {Object} modifications - Properties to override
             * @returns {StrokeStyle} - A new StrokeStyle with the modifications applied
             */
            withChanges(modifications) {
                const baseOptions = {
                    color: this.color,
                    lineWidth: this._lineWidth,
                    lineCap: this.lineCap,
                    normalized: this.normalized,
                    opacity: this.opacity,
                    lineDash: [...this.lineDash],
                    headLength: this.headLength,
                    headWidth: this.headWidth,
                    shadowBlur: this.shadowBlur,
                    shadowColor: this.shadowColor,
                    animatable: this.animatable,
                    pulsate: this.pulsate
                };
                // Apply modifications
                const newOptions = { ...baseOptions, ...modifications };

                return new StrokeStyle(newOptions, this.config);
            }

            /**
             * Create a style for language-specific stroke rendering
             * @param {string} langCode - The language code
             * @param {Object} styleType - The style type (guide, highlight, etc.)
             * @returns {StrokeStyle} - A StrokeStyle configured for the language
             */
            static forLanguage(langCode, styleType, config) {
                // Get base style for this type
                const baseStyle = config.styles[styleType];

                // Check for language-specific overrides
                const langStyle = config.languageStyles &&
                    config.languageStyles[langCode] &&
                    config.languageStyles[langCode][styleType];

                // Merge styles, with language-specific taking precedence
                const mergedStyle = { ...baseStyle, ...(langStyle || {}) };

                return new StrokeStyle(mergedStyle, config);
            }

            /**
           * Generate dynamic styles for stroke animations
           * @param {number} progress - Animation progress (0-1)
           * @returns {StrokeStyle} - A modified style for the current animation frame
           */
            forAnimationProgress(progress) {
                if (!this.animatable) return this;

                const modifications = {};

                // Pulsating effect
                if (this.pulsate) {
                    // Make the line pulse in width
                    const pulseRate = 2; // Complete pulse cycles during animation
                    const pulseAmount = 0.3; // How much to pulse (30% variation)
                    const pulseFactor = 1 + pulseAmount * Math.sin(progress * Math.PI * 2 * pulseRate);
                    modifications.lineWidth = this._lineWidth * pulseFactor;
                }

                // Fading effect for appearing/disappearing
                if (progress < 0.2) {
                    // Fade in at start
                    modifications.opacity = progress * 5 * this.opacity;
                } else if (progress > 0.8) {
                    // Fade out at end
                    modifications.opacity = ((1 - progress) * 5) * this.opacity;
                }

                return this.withChanges(modifications);
            }

            // --- Getters ---
            /**
             * Get the scaled line width
             * @returns {number} - The scaled line width
             */
            get lineWidth() {
                let scaled = Utils.scaleToCanvas(this._lineWidth, this.config, 'width');
                return scaled
            }
            /**
             * Get the scaled head length (for arrows)
             * @returns {number} - The scaled head length
             */
            get headLength() {
                let scaled = Utils.scaleToCanvas(this._headLength, this.config, 'width');
                return scaled
            }
            /**
             * Get the scaled head width (for arrows)
             * @returns {number} - The scaled head width
             */
            get headWidth() {
                let scaled = Utils.scaleToCanvas(this._headWidth, this.config, 'width');
                return scaled
            }
        }


        /**
         * Base Stroke class representing a single drawing movement
         * Provides common functionality for all stroke types
         */
        class Stroke {
            /**
             * Create a new stroke
             * @param {Object} config - App configuration
             * @param {Object} strokeData - Stroke configuration
             * @param {string} strokeData.type - Type of stroke ('line', 'curve', 'compound')
             * @param {Array<Object>} strokeData.points - Array of point coordinates
             * @param {number} [strokeData.lineWidth] - Optional custom line width
             * @param {string} [strokeData.lineCap] - Optional custom line cap style
             */
            constructor(config, strokeData) {
                this.config = config;
                this.type = strokeData.type;
                if ((this.type == 'line') || (this.type == 'curve')) {
                    this.points = strokeData.points.map(p => new Point(p.x, p.y, this.config, true)); // expected to be norm
                    this.lineWidth = strokeData.lineWidth;
                    this.lineCap = strokeData.lineCap;
                } else if (this.type == 'compound') {
                    this.subStrokes = strokeData.subStrokes
                }

                // Store arrow style if provided. Not a full Style object!
                if (strokeData.arrowStyle) {
                    this.arrowStyle = strokeData.arrowStyle || null;
                }
                

                // Calculate path length for progress calculations
                //console.log(this); console.log(this.type); console.log(this.points); console.log(strokeData);

                this._pathLength = -1;
            }

            get pathLength() {
                if (this._pathLength == -1) {
                    this._pathLength = this.calculatePathLength();
                }
                return this._pathLength
            }

            /**
             * Calculate the total length of the stroke path
             * @param {number} [numSegments=100] - Number of segments for curve approximation
             * @returns {number} Path length in pixels
             */
            calculatePathLength(numSegments = 100) {
                // Abstract method to be implemented by subclasses
                throw new Error('calculatePathLength must be implemented by subclasses');
            }

            /**
             * Draw the stroke on a canvas context
             * @param {CanvasRenderingContext2D} ctx - Canvas context
             * @param {StrokeStyle} style - Style to apply
             * @param {number} [progress=1] - Drawing progress (0-1)
             */
            draw(ctx, style, progress = 1) {
                // Save the context state
                ctx.save();

                // Apply style
                ctx.strokeStyle = style.color || '#000000';
                //ctx.lineWidth = this.lineWidth ?
                //    Utils.scaleToCanvas(this.lineWidth, this.config, 'width') :
                //    style.lineWidth;
                ctx.lineWidth = this.lineWidth;
                ctx.lineCap = this.lineCap || style.lineCap || 'round';

                // Begin the path
                ctx.beginPath();

                // Actual drawing implemented by subclasses
                this.drawPath(ctx, progress);

                // Stroke the path
                ctx.stroke();

                // Restore the context state
                ctx.restore();
            }

            /**
             * Draw the actual path on the context (to be implemented by subclasses)
             * @param {CanvasRenderingContext2D} ctx - Canvas context
             * @param {number} progress - Drawing progress (0-1)
             */
            drawPath(ctx, progress) {
                throw new Error('drawPath must be implemented by subclasses');
            }

            /**
             * Get a point along the stroke at the specified progress
             * @param {number} progress - Position along the stroke (0-1)
             * @returns {Point} Point at the specified position
             */
            getPointAt(progress) {
                // Abstract method to be implemented by subclasses
                throw new Error('getPointAt must be implemented by subclasses');
            }

            /**
             * Draw direction indicator for the stroke
             * @param {CanvasRenderingContext2D} ctx - Canvas context
             * @param {StrokeStyle} style - Arrow style
             */
            drawDirections(ctx, style) {
                // Default implementation draws a simple arrow
                const baseArrowStyle = {
                    color: style.color || '#FFA500',
                    lineWidth: style.lineWidth || 3,
                    headLength: style.headLength || 15,
                    headWidth: style.headWidth || 10
                };
                const arrowStyle = style || baseArrowStyle;
                // Get stroke points for drawing the arrow
                this.drawArrow(ctx, arrowStyle);
            }

            /**
             * Draw an arrow showing the stroke direction
             * @param {CanvasRenderingContext2D} ctx - Canvas context
             * @param {Object} style - Arrow style properties
             */
            drawArrow(ctx, style) {
                // To be implemented by subclasses based on their geometry
                throw new Error('drawArrow must be implemented by subclasses');
            }

            /**
             * Calculate accuracy of user's drawn path compared to this stroke
             * @param {Array<Point>} userPath - Array of points from user's drawing
             * @returns {number} Accuracy percentage (0-100)
             */
            calculateAccuracy(userPath) {
                if (userPath.length < 2) return 0;

                const config = this.config.accuracy;
                const numSamples = config.samplePoints;
                const maxAllowedError = config.maxError;
                const thresh = config.threshold;
                let totalError = 0;

                // process user path
                const pUserPath = Utils.processPath(userPath); // rel lengths
                // Sample points along both paths
                for (let i = 0; i <= numSamples; i++) {
                    const t = i / numSamples;

                    const idealPoint = this.getPointAt(t);
                    const userPoint = Utils.interpolatePathPoint(userPath, pUserPath, t);

                    // Calculate error (distance between points)
                    let error = Utils.distance(idealPoint, userPoint);

                    // Handle NaN errors (shouldn't happen with proper implementation)
                    if (isNaN(error)) {
                        error = maxAllowedError * 2;
                        console.warn('NaN error encountered during accuracy calculation');
                    }

                    totalError += error;

                }

                // Calculate average error and convert to accuracy percentage
                const avgError = totalError / (numSamples + 1);
                return Math.max(0, Math.min(100, 100 * (1 - avgError / maxAllowedError)));
            }

            /**
             * Animate drawing the stroke
             * @param {CanvasRenderingContext2D} ctx - Canvas context
             * @param {StrokeStyle} style - Style to apply
             * @param {number} duration - Animation duration in ms
             * @param {boolean} [drawOver=false] - Whether to use destination-over blending
             * @returns {Promise} Promise that resolves when animation completes
             */
            async animateStroke(ctx, style, duration, drawOver = false) {
                return new Promise(resolve => {
                    let startTime = null;

                    // Store the original composite operation
                    const originalComposite = ctx.globalCompositeOperation;

                    function animate(timestamp) {
                        if (!startTime) startTime = timestamp;
                        const progress = Math.min((timestamp - startTime) / duration, 1);

                        // Clear previous frame
                        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

                        // Set blending mode if needed
                        if (drawOver) {
                            ctx.globalCompositeOperation = 'destination-over';
                        }

                        // Draw the stroke with current progress
                        this.draw(ctx, style, progress);

                        if (progress < 1) {
                            requestAnimationFrame(animate.bind(this));
                        } else {
                            // Reset composite operation
                            ctx.globalCompositeOperation = originalComposite;
                            resolve();
                        }
                    }

                    requestAnimationFrame(animate.bind(this));
                });
            }
        }

        /**
         * Line stroke representing a straight line segment
         * @extends Stroke
         */
        class LineStroke extends Stroke {
            /**
             * Create a new line stroke
             * @param {Object} config - App configuration
             * @param {Object} strokeData - Stroke data
             * @param {Array<Object>} strokeData.points - Two points defining the line
             */
            constructor(config, strokeData) {
                super(config, { ...strokeData, type: 'line' });

                // Validate that we have exactly two points
                if (this.points.length !== 2) {
                    throw new Error('LineStroke requires exactly two points');
                }
            }

            /**
             * Calculate the length of the line
             * @returns {number} Line length in pixels
             */
            calculatePathLength() {
                const [p0, p1] = this.points;
                return Utils.distance(p0, p1);
            }

            /**
             * Draw the line path
             * @param {CanvasRenderingContext2D} ctx - Canvas context
             * @param {number} progress - Drawing progress (0-1)
             */
            drawPath(ctx, progress) {
                const start = this.points[0];
                const end = this.getPointAt(progress);

                ctx.moveTo(start.x, start.y);
                ctx.lineTo(end.x, end.y);
            }

            /**
             * Get a point along the line at the specified progress
             * @param {number} progress - Position along the line (0-1)
             * @returns {Point} Point at the specified position
             */
            getPointAt(progress) {
                const start = this.points[0];
                const end = this.points[1];

                return new Point(
                    start.x + (end.x - start.x) * progress,
                    start.y + (end.y - start.y) * progress,
                    this.config,
                    false // Not normalized
                );
            }

            /**
             * Draw an arrow showing the stroke direction
             * @param {CanvasRenderingContext2D} ctx - Canvas context
             * @param {Object} style - Arrow style properties
             */
            drawArrow(ctx, style) {
                // Use stroke-specific arrow style if available, otherwise use provided style
                const arrowStyle = this.arrowStyle ? Utils.mergeStyles(style, this.arrowStyle, true) : style;
             
                const [start, end] = this.points;

                // Draw the line
                ctx.save();
                ctx.strokeStyle = arrowStyle.color;
                ctx.lineWidth = arrowStyle.lineWidth;
                ctx.beginPath();
                ctx.moveTo(start.x, start.y);
                ctx.lineTo(end.x, end.y);
                ctx.stroke();

                // Calculate arrow position (midpoint)
                const midX = (start.x + end.x) / 2;
                const midY = (start.y + end.y) / 2;

                // Calculate tangent vector (normalized)
                const dx = end.x - start.x;
                const dy = end.y - start.y;
                const length = Math.sqrt(dx * dx + dy * dy);
                const tangent = { x: dx / length, y: dy / length };

                const headLength = arrowStyle.headLength;
                const headWidth = arrowStyle.headWidth;

                // Draw arrowhead
                ctx.fillStyle = arrowStyle.color;
                ctx.beginPath();
                ctx.moveTo(midX, midY);
                // Calculate angle and arrowhead points
                // const angle = Math.atan2(end.y - start.y, end.x - start.x);
                //ctx.lineTo(
                //    midX - headLength * Math.cos(angle - Math.PI / 6),
                //    midY - headLength * Math.sin(angle - Math.PI / 6)
                //);
                //ctx.lineTo(
                //    midX - headLength * Math.cos(angle + Math.PI / 6),
                //    midY - headLength * Math.sin(angle + Math.PI / 6)
                //);
                ctx.lineTo(
                    midX - headLength * tangent.x - headWidth * tangent.y,
                    midY - headLength * tangent.y + headWidth * tangent.x
                );
                ctx.lineTo(
                    midX - headLength * tangent.x + headWidth * tangent.y,
                    midY - headLength * tangent.y - headWidth * tangent.x
                );
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }
        }

        /**
         * Curve stroke representing a cubic Bezier curve
         * @extends Stroke
         */
        class CurveStroke extends Stroke {
            /**
             * Create a new curve stroke
             * @param {Object} config - App configuration
             * @param {Object} strokeData - Stroke data
             * @param {Array<Object>} strokeData.points - Four points defining the cubic Bezier
             */
            constructor(config, strokeData) {
                super(config, { ...strokeData, type: 'curve' });

                // Validate that we have exactly four points
                if (this.points.length !== 4) {
                    throw new Error('CurveStroke requires exactly four points');
                }
            }

            /**
             * Calculate an approximation of the curve length
             * @param {number} [numSegments=100] - Number of segments for approximation
             * @returns {number} Approximate curve length in pixels
             */
            calculatePathLength(numSegments = 100) {
                let length = 0;
                let prevPoint = this.getPointAt(0);

                for (let i = 1; i <= numSegments; i++) {
                    const t = i / numSegments;
                    const point = this.getPointAt(t);
                    length += Utils.distance(prevPoint, point);
                    prevPoint = point;
                }

                return length;
            }

            /**
             * Draw the curve path
             * @param {CanvasRenderingContext2D} ctx - Canvas context
             * @param {number} progress - Drawing progress (0-1)
             */
            drawPath(ctx, progress) {
                const [p0, p1, p2, p3] = this.points;

                if (progress === 1) {
                    // Draw full curve
                    ctx.moveTo(p0.x, p0.y);
                    ctx.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
                } else {
                    // Draw partial curve
                    ctx.moveTo(p0.x, p0.y);

                    // Calculate control points for partial curve
                    const partial = this.getPartialBezierControlPoints(progress);
                    ctx.bezierCurveTo(
                        partial.cp1.x, partial.cp1.y,
                        partial.cp2.x, partial.cp2.y,
                        partial.end.x, partial.end.y
                    );
                }
            }

            /**
             * Get control points for a partial Bezier curve
             * @param {number} t - Progress along the curve (0-1)
             * @returns {Object} Object with cp1, cp2 and end points
             */
            getPartialBezierControlPoints(t) {
                const result = Utils.calculatePartialBezier(t, this);
                return {
                    cp1: { x: result.newCx1, y: result.newCy1 },
                    cp2: { x: result.newCx2, y: result.newCy2 },
                    end: { x: result.newX2, y: result.newY2 }
                };
            }

            /**
             * Get a point along the curve at the specified progress
             * @param {number} t - Position along the curve (0-1)
             * @returns {Point} Point at the specified position
             */
            getPointAt(t) {
                const [p0, p1, p2, p3] = this.points;
                const mt = 1 - t;

                // Cubic Bezier formula
                const x = mt * mt * mt * p0.x +
                    3 * mt * mt * t * p1.x +
                    3 * mt * t * t * p2.x +
                    t * t * t * p3.x;

                const y = mt * mt * mt * p0.y +
                    3 * mt * mt * t * p1.y +
                    3 * mt * t * t * p2.y +
                    t * t * t * p3.y;

                return new Point(x, y, this.config, false); // Not normalized
            }

            /**
             * Get the tangent vector at a specific point on the curve
             * @param {number} t - Position along the curve (0-1)
             * @returns {Object} Normalized tangent vector {x, y}
             */
            getTangentAt(t) {
                const [p0, p1, p2, p3] = this.points;
                const mt = 1 - t;

                // Derivative of cubic Bezier
                const dx = 3 * mt * mt * (p1.x - p0.x) +
                    6 * mt * t * (p2.x - p1.x) +
                    3 * t * t * (p3.x - p2.x);

                const dy = 3 * mt * mt * (p1.y - p0.y) +
                    6 * mt * t * (p2.y - p1.y) +
                    3 * t * t * (p3.y - p2.y);

                // Normalize
                const length = Math.sqrt(dx * dx + dy * dy);

                return {
                    x: dx / length,
                    y: dy / length
                };
            }

            /**
             * Draw arrows showing the curve direction
             * @param {CanvasRenderingContext2D} ctx - Canvas context
             * @param {Object} style - Arrow style properties
             */
            drawArrow(ctx, style) {
                // method of curvestroke
                // Use stroke-specific arrow style if available, otherwise use provided style
                console.log(style);
                const arrowStyle = this.arrowStyle ?
                    new StrokeStyle(Utils.mergeStyles(style, this.arrowStyle, true),this.config) : style;
                
                ctx.save();

                // Draw the curve path
                ctx.strokeStyle = arrowStyle.color;
                ctx.lineWidth = arrowStyle.lineWidth;
                console.log(arrowStyle);

                ctx.beginPath();
                const [p0, p1, p2, p3] = this.points;
                ctx.moveTo(p0.x, p0.y);
                ctx.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
                ctx.stroke();

                // Draw arrowheads at intervals
                const arrowPositions = [0.25, 0.5, 0.75];

                arrowPositions.forEach(t => {
                    const point = this.getPointAt(t);
                    const tangent = this.getTangentAt(t);

                    // Calculate arrowhead points
                    const headLength = arrowStyle.headLength;
                    const headWidth = arrowStyle.headWidth;

                    ctx.fillStyle = arrowStyle.color;
                    ctx.beginPath();
                    ctx.moveTo(point.x, point.y);
                    ctx.lineTo(
                        point.x - headLength * tangent.x - headWidth * tangent.y,
                        point.y - headLength * tangent.y + headWidth * tangent.x
                    );
                    ctx.lineTo(
                        point.x - headLength * tangent.x + headWidth * tangent.y,
                        point.y - headLength * tangent.y - headWidth * tangent.x
                    );
                    ctx.closePath();
                    ctx.fill();
                });

                ctx.restore();
            }
        }

        /**
         * Compound stroke composed of multiple sub-strokes
         * @extends Stroke
         */
        class CompoundStroke extends Stroke {
            /**
             * Create a new compound stroke
             * @param {Object} config - App configuration
             * @param {Object} strokeData - Stroke data
             * @param {Array<Object>} strokeData.subStrokes - Array of sub-stroke definitions
             */
            constructor(config, strokeData) {
                super(config, { ...strokeData, type: 'compound' });

                // Create sub-strokes based on their types
                this.subStrokes = strokeData.subStrokes.map(s => {
                    if (s.type === 'line') return new LineStroke(this.config, s);
                    if (s.type === 'curve') return new CurveStroke(this.config, s);
                    if (s.type === 'compound') return new CompoundStroke(this.config, s);
                    throw new Error(`Unknown stroke type: ${s.type}`);
                });

                // Prep for calculated relative lengths. used for progress mapping
                this._relativeLengths = []; // Self initializes on first call
                this._pathLength = -1; // Total length. Self initializes on first call
                this._subStrokeRanges = [];
                this.totalLength = -1;
            }

            /**
             * Self initializes on first call
             */
            get relativeLengths() {
                if (this._relativeLengths.length == 0) {
                    this._relativeLengths = this.calculateRelativeLengths();
                }
                return this._relativeLengths
            }
            get pathLength() {
                if (this._pathLength == -1) this._pathLength = this.calculatePathLength();
                return this._pathLength
            }
            get subStrokeRanges() {
                if (this._relativeLengths.length == 0) {
                    this._relativeLengths = this.calculateRelativeLengths();
                }
                return this._subStrokeRanges

            }
            /**
             * Calculate the total length and relative proportions of each sub-stroke. some extra bits I don't think are being used rn
             */
            calculateRelativeLengths() {
                const lengths = this.subStrokes.map(s => s.calculatePathLength());
                this.totalLength = lengths.reduce((sum, length) => sum + length, 0);

                let accumulatedProportion = 0;
                this._subStrokeRanges = [];

                for (let i = 0; i < lengths.length; i++) {
                    const proportion = lengths[i] / this.totalLength;
                    this._subStrokeRanges.push({
                        start: accumulatedProportion,
                        end: accumulatedProportion + proportion,
                        proportion
                    });
                    accumulatedProportion += proportion;
                }
                return this._subStrokeRanges.map((ssRng) => ssRng.proportion);
            }

            /**
             * Calculate the total path length of all sub-strokes
             * @returns {number} Total length in pixels
             */
            calculatePathLength() {
                return this.subStrokes.reduce((sum, s) => sum + s.pathLength(), 0);
            }

            /**
             * Draw the compound stroke
             * @param {CanvasRenderingContext2D} ctx - Canvas context
             * @param {StrokeStyle} style - Style to apply
             * @param {number} progress - Drawing progress (0-1)
             */
            draw(ctx, style, progress = 1) {
                if (progress >= 1) {
                    // Draw all sub-strokes completely
                    this.subStrokes.forEach(stroke => stroke.draw(ctx, style, 1));
                    return;
                }

                // Find which sub-stroke to draw based on progress
                for (let i = 0; i < this.subStrokeRanges.length; i++) {
                    console.log('partial drawing of compound needs Stroke.subStrokeRanges');
                    const range = this.subStrokeRanges[i];

                    if (progress <= range.end) {
                        // Calculate sub-stroke progress
                        const subProgress = (progress - range.start) / range.proportion;

                        // Draw all previous sub-strokes completely
                        for (let j = 0; j < i; j++) {
                            this.subStrokes[j].draw(ctx, style, 1);
                        }

                        // Draw current sub-stroke partially
                        this.subStrokes[i].draw(ctx, style, subProgress);

                        break;
                    }
                }
            }

            /**
             * Get the right sub-stroke and position for the given progress
             * @param {number} progress - Global progress (0-1)
             * @returns {Object} Object containing sub-stroke and its local progress
             */
            getSubStrokeForProgress(progress) {
                for (let i = 0; i < this.subStrokeRanges.length; i++) {
                    const range = this.subStrokeRanges[i];

                    if (progress <= range.end) {
                        // Calculate sub-stroke progress
                        const subProgress = (progress - range.start) / range.proportion;
                        return {
                            subStroke: this.subStrokes[i],
                            progress: subProgress
                        };
                    }
                }

                // If we're at the end or beyond
                return {
                    subStroke: this.subStrokes[this.subStrokes.length - 1],
                    progress: 1
                };
            }

            /**
             * Get a point along the compound stroke
             * @param {number} progress - Position along the stroke (0-1)
             * @returns {Point} Point at the specified position
             */
            getPointAt(progress) {
                const { subStroke, progress: subProgress } = this.getSubStrokeForProgress(progress);
                return subStroke.getPointAt(subProgress);
            }

            /**
             * Draw the path of the compound stroke
             * @param {CanvasRenderingContext2D} ctx - Canvas context
             * @param {number} progress - Drawing progress (0-1)
             */
            drawPath(ctx, progress) {
                this.draw(ctx, null, progress);
            }

            /**
             * Draw direction indicators for all sub-strokes
             * @param {CanvasRenderingContext2D} ctx - Canvas context
             * @param {StrokeStyle} style - Arrow style
             */
            drawDirections(ctx, style) {
                this.subStrokes.forEach(stroke => stroke.drawDirections(ctx, style));
            }

            /**
             * Draw an arrow for the compound stroke
             * @param {CanvasRenderingContext2D} ctx - Canvas context
             * @param {Object} style - Arrow style properties
             */
            drawArrow(ctx, style) {
                this.subStrokes.forEach(stroke => stroke.drawArrow(ctx, style));
            }

            /**
             * Animate drawing the compound stroke
             * @param {CanvasRenderingContext2D} ctx - Canvas context
             * @param {StrokeStyle} style - Style to apply
             * @param {number} duration - Animation duration in ms
             * @param {boolean} [drawOver=false] - Whether to use destination-over blending
             * @returns {Promise} Promise that resolves when animation completes
             */
            async animateStroke(ctx, style, duration, drawOver = false) {
                // Animate each sub-stroke in sequence, with proportional duration
                for (let i = 0; i < this.subStrokes.length; i++) {
                    const stroke = this.subStrokes[i];
                    const proportion = this.subStrokeRanges[i].proportion;
                    await stroke.animateStroke(ctx, style, duration * proportion, drawOver);
                }
            }
        }


        /**
         * Represents a complete letter/character with its strokes and rendering properties.
         * Handles different writing systems and language-specific stroke behaviors.
         * reverse may not be necessary meaning and pronounciation may not be necessary here either
         */
        class Letter {
            /**
             * Creates a new Letter instance
             * @param {Object} config - App configuration
             * @param {string} character - The character this letter represents
             * @param {Object} letterData - Letter configuration options
             * @param {Array} letterData.strokes - Stroke data for practice
             * @param {Array} [letterData.fontStrokes] - Optional alternative strokes for display
             */

            constructor(config, character, letterData) {
                this.character = character;
                this.config = config;// options.config;
                this.direction = config.direction;

                // Create stroke objects from stroke data
                this.strokes = this.createStrokes(letterData.strokes);

                // Font strokes are optional (used for display when different from practice strokes)
                this.fontStrokes = letterData.fontStrokes ?
                    this.createStrokes(letterData.fontStrokes) : null;

                // Language-specific properties
                this.metadata = letterData.metadata || {};
            }

            /**
             * Creates appropriate stroke objects based on stroke data
             * @param {Array} strokesData - Raw stroke data
             * @returns {Array} - Array of Stroke objects
             */
            createStrokes(strokesData) {
                return strokesData.map(strokeData => {
                    switch (strokeData.type) {
                        case 'line':
                            return new LineStroke(this.config, strokeData);
                        case 'curve':
                            return new CurveStroke(this.config, strokeData);
                        case 'compound':
                            return new CompoundStroke(this.config, strokeData);
                        default:
                            console.warn(`Unknown stroke type: ${strokeData.type}`);
                            return null;
                    }
                }).filter(stroke => stroke !== null);
            }

            /**
             * Gets the strokes to be displayed for practice
             * @returns {Array} - Array of Stroke objects
             */
            getPracticeStrokes() {
                return this.strokes;
            }

            /**
             * Gets the strokes to be displayed for demonstration
             * @returns {Array} - Array of Stroke objects
             */
            getDisplayStrokes() {
                return this.fontStrokes || this.strokes;
            }

            /**
             * Draw the letter on a canvas context
             * @param {CanvasRenderingContext2D} ctx - Canvas context
             * @param {StrokeStyle} style - Style to use for drawing
             * @param {boolean} useFont - Whether to use font strokes
             */
            draw(ctx, style, useFont = false) {
                const strokesToDraw = useFont ? this.getDisplayStrokes() : this.getPracticeStrokes();

                strokesToDraw.forEach(stroke => {
                    stroke.draw(ctx, style);
                });
            }

            /**
             * Draw a specific stroke of the letter
             * @param {CanvasRenderingContext2D} ctx - Canvas context
             * @param {number} index - Index of the stroke to draw
             * @param {StrokeStyle} style - Style to use for drawing
             * @param {boolean} useFont - Whether to use font strokes
             * @param {number} progress - Progress of the stroke (0-1)
             */
            drawStroke(ctx, index, style, useFont = false, progress = 1) {
                const strokesToDraw = useFont ? this.getDisplayStrokes() : this.getPracticeStrokes();

                if (index >= 0 && index < strokesToDraw.length) {
                    strokesToDraw[index].draw(ctx, style, progress);
                }
            }

            /**
             * Get the total number of strokes in this letter
             * @returns {number} - Number of strokes
             */
            getStrokeCount() {
                return this.strokes.length;
            }

            /**
             * Calculate accuracy of a user's drawn path for a specific stroke
             * @param {number} strokeIndex - Index of the stroke to check
             * @param {Array} userPath - User's drawing path
             * @returns {number} - Accuracy percentage (0-100)
             */
            calculateStrokeAccuracy(strokeIndex, userPath) {
                if (strokeIndex >= 0 && strokeIndex < this.strokes.length) {
                    return this.strokes[strokeIndex].calculateAccuracy(userPath);
                }
                return 0;
            }

            /**
             * Get pronunciation hint if available
             * @returns {string|null} - Pronunciation hint
             */
            getPronunciation() {
                return this.metadata.pronunciation || null;
            }

            /**
             * Get meaning/translation if available
             * @returns {string|null} - Character meaning
             */
            getMeaning() {
                return this.metadata.meaning || null;
            }

            /**
             * Get a hint about how to draw this letter
             * @returns {string|null} - Hint text
             */
            getHint() {
                return this.metadata.hint || null;
            }


            /**
             * Creates a plain object representation of this letter
             * @returns {Object} - Serializable letter data
             */
            toJSON() {
                return {
                    character: this.character,
                    strokes: this.strokes.map(stroke => stroke.toJSON()),
                    fontStrokes: this.fontStrokes ? this.fontStrokes.map(stroke => stroke.toJSON()) : null,
                    metadata: this.metadata
                };
            }
        }

        // --- Views ---
        /**
         * Canvas layer manager for handling a single canvas element in the drawing app
         * Encapsulates drawing operations and canvas state management
         */
        class CanvasLayer {
            /**
             * Create a new canvas layer
             * @param {string} id - The ID of the canvas element in the DOM
             * @param {number} zIndex - The stacking order of this layer
             * @param {Object} config - Configuration object containing canvas settings
             */
            constructor(id, zIndex, config) {
                this.id = id;
                this.canvas = document.getElementById(id);
                this.config = config;

                if (!this.canvas) {
                    throw new Error(`Canvas element with ID "${id}" not found`);
                }

                this.context = this.canvas.getContext('2d');
                this.canvas.style.zIndex = zIndex;

                // Apply dimension settings from config
                this.width = config.canvas.width;
                this.height = config.canvas.height;
                this.canvas.width = this.width;
                this.canvas.height = this.height;


                // Cache for improved performance
                this.imageCache = {};

                // Set up touch handling
                this.setupTouchEvents();
            }

            /**
             * Set up touch event handling for mobile devices
             */
            setupTouchEvents() {
                // Make sure touch events don't trigger scrolling
                this.canvas.style.touchAction = 'none';
            }

            /**
             * Clear the canvas
             */
            clear() {
                this.context.clearRect(0, 0, this.width, this.height);
                return this; // Enable method chaining
            }

            /**
             * Save the current canvas state to cache
             * @param {string} key - Cache identifier
             * @returns {ImageData} The saved image data
             */
            saveState(key) {
                const imageData = this.context.getImageData(0, 0, this.width, this.height);
                this.imageCache[key] = imageData;
                return imageData;
            }

            /**
             * Restore canvas state from cache
             * @param {string} key - Cache identifier
             * @param {boolean} [remove=false] - Whether to remove the cached item after restoring
             * @returns {CanvasLayer} This canvas layer for method chaining
             */
            restoreState(key, remove = false) {
                if (this.imageCache[key]) {
                    this.context.putImageData(this.imageCache[key], 0, 0);
                    if (remove) {
                        delete this.imageCache[key];
                    }
                } else {
                    console.warn(`No cached state found for key: ${key}`);
                }
                return this;
            }

            /**
             * Remove a cached state
             * @param {string} key - Cache identifier
             */
            clearState(key) {
                delete this.imageCache[key];
            }

            /**
             * Set the composite operation for the canvas
             * @param {string} operation - Canvas composite operation
             * @returns {CanvasLayer} This canvas layer for method chaining
             */
            setCompositeOperation(operation) {
                this.context.globalCompositeOperation = operation;
                return this;
            }

            /**
             * Apply a drawing style to the context
             * @param {Object} style - Style object with color, lineWidth, etc.
             * @returns {CanvasLayer} This canvas layer for method chaining
             */
            applyStyle(style) {
                if (!style) return this;

                if (style.color) this.context.strokeStyle = style.color;
                if (style.fillColor) this.context.fillStyle = style.fillColor;

                if (style.lineWidth) {
                    // Handle normalized line widths
                    this.context.lineWidth = style.normalized ?
                        style.lineWidth * this.width :
                        style.lineWidth;
                }

                if (style.lineCap) this.context.lineCap = style.lineCap;
                if (style.lineJoin) this.context.lineJoin = style.lineJoin;
                if (style.font) this.context.font = style.font;
                if (style.textAlign) this.context.textAlign = style.textAlign;
                if (style.textBaseline) this.context.textBaseline = style.textBaseline;

                return this;
            }

            /**
             * Draw a letter using the canvas text API
             * @param {string} letter - The letter character to draw
             * @param {Object} [options] - Text rendering options
             */
            drawLetter(letter, options = {}) { // currently unused
                const defaultOptions = {
                    x: this.width / 2,
                    y: this.height / 2,
                    font: 'bold 250px Arial',
                    color: '#DDDDDD',
                    textAlign: 'center',
                    textBaseline: 'middle'
                };

                const opts = { ...defaultOptions, ...options };

                this.context.font = opts.font;
                this.context.fillStyle = opts.color;
                this.context.textAlign = opts.textAlign;
                this.context.textBaseline = opts.textBaseline;

                // Consider text direction for RTL languages
                if (this.config.direction === 'rtl') {
                    this.context.direction = 'rtl';
                }

                this.context.fillText(letter, opts.x, opts.y);
                return this;
            }

            /**
             * Draw a path based on a series of points
             * @param {Array<Object>} points - Array of {x, y} points
             * @param {Object} style - Style to apply to the path
             * @returns {CanvasLayer} This canvas layer for method chaining
             */
            drawPath(points, style) {
                if (!points || points.length < 2) return this;

                this.applyStyle(style);
                this.context.beginPath();
                this.context.moveTo(points[0].x, points[0].y);

                for (let i = 1; i < points.length; i++) {
                    this.context.lineTo(points[i].x, points[i].y);
                }

                this.context.stroke();
                return this;
            }

            /**
             * Draw an arrow to indicate stroke direction
             * @param {Object} start - Start point {x, y}
             * @param {Object} end - End point {x, y}
             * @param {Object} arrowStyle - Style to apply to the arrow
             * @returns {CanvasLayer} This canvas layer for method chaining
             */
            drawArrow(start, end, arrowStyle) {
                console.log('canvas layer drawArrow');
                const headLength = arrowStyle.headLength || (this.width * 0.03);
                const headWidth = arrowStyle.headWidth || (this.width * 0.05);

                // Calculate angle and midpoint
                const angle = Math.atan2(end.y - start.y, end.x - start.x);
                const midX = (start.x + end.x) / 2;
                const midY = (start.y + end.y) / 2;

                this.applyStyle(arrowStyle);

                // Draw line
                this.context.beginPath();
                this.context.moveTo(start.x, start.y);
                this.context.lineTo(end.x, end.y);
                this.context.stroke();

                // Draw arrowhead
                const halfHeadLength = headLength / 2;
                const arrowAngle = Math.atan(headWidth / (2 * headLength));
                const hypotenuse = (headWidth / 2) / Math.sin(arrowAngle);

                const headPoint = {
                    x: midX + halfHeadLength * Math.cos(angle),
                    y: midY + halfHeadLength * Math.sin(angle)
                };

                const headCorner1 = {
                    x: headPoint.x - hypotenuse * Math.cos(angle - arrowAngle),
                    y: headPoint.y - hypotenuse * Math.sin(angle - arrowAngle)
                };

                const headCorner2 = {
                    x: headPoint.x - hypotenuse * Math.cos(angle + arrowAngle),
                    y: headPoint.y - hypotenuse * Math.sin(angle + arrowAngle)
                };

                this.context.beginPath();
                this.context.moveTo(headPoint.x, headPoint.y);
                this.context.lineTo(headCorner1.x, headCorner1.y);
                this.context.lineTo(headCorner2.x, headCorner2.y);
                this.context.closePath();
                this.context.fillStyle = arrowStyle.color || this.context.strokeStyle;
                this.context.fill();

                return this;
            }

            /**
             * Draw a bezier curve
             * @param {Array<Object>} points - Control points [start, cp1, cp2, end]
             * @param {Object} style - Style to apply to the curve
             * @param {number} [progress=1] - How much of the curve to draw (0-1)
             * @returns {CanvasLayer} This canvas layer for method chaining
             */
            drawBezierCurve(points, style, progress = 1) {
                if (!points || points.length !== 4) return this;

                this.applyStyle(style);
                this.context.beginPath();
                this.context.moveTo(points[0].x, points[0].y);

                if (progress === 1) {
                    // Draw full curve
                    this.context.bezierCurveTo(
                        points[1].x, points[1].y,
                        points[2].x, points[2].y,
                        points[3].x, points[3].y
                    );
                } else {
                    // Draw partial curve using the utility function
                    const partial = Utils.calculatePartialBezier(progress,
                        points[0], points[1], points[2], points[3]);

                    this.context.bezierCurveTo(
                        partial.newCx1, partial.newCy1,
                        partial.newCx2, partial.newCy2,
                        partial.newX2, partial.newY2
                    );
                }

                this.context.stroke();
                return this;
            }

            /**
             * Draw directly onto another canvas layer
             * @param {CanvasLayer} targetLayer - Target canvas layer
             * @param {string} [compositeOperation='source-over'] - Composite operation
             * @returns {CanvasLayer} This canvas layer for method chaining
             */
            drawOnto(targetLayer, compositeOperation = 'source-over') {
                const prevOperation = targetLayer.context.globalCompositeOperation;
                targetLayer.context.globalCompositeOperation = compositeOperation;
                targetLayer.context.drawImage(this.canvas, 0, 0);
                targetLayer.context.globalCompositeOperation = prevOperation;
                return this;
            }

            /**
             * Clean up resources used by this canvas layer
             */
            destroy() {
                // Clear event listeners to prevent memory leaks
                this.canvas.removeEventListener('mousedown', this._boundMouseDown);
                this.canvas.removeEventListener('touchstart', this._boundTouchStart);

                // Clear image cache
                this.imageCache = {};

                // Remove canvas from DOM if needed
                // this.canvas.parentNode.removeChild(this.canvas);
            }
        }

        /**
         * View manager responsible for all rendering
         */
        class LetterView {
            /**
             * Initialize the view with configuration
             * @param {Object} config - The application configuration
             */
            constructor(config) {
                this.config = config;

                // Initialize canvas layers
                this.layers = {};
                this.initializeCanvasLayers();

                // Store DOM elements for UI updates
                this.elements = {
                    instruction: document.getElementById('instruction'),
                    accuracy: document.getElementById('accuracy')
                };

                // Apply initial styles based on config
                this.applyConfigStyles();
            }

            /**
             * Initialize all canvas layers with proper z-index
             */
            initializeCanvasLayers() {
                const layerConfig = this.config.canvas.layers; // is array

                // Create layers in specified order (id, zIndex, config)
                layerConfig.forEach((layerId, index) => {
                    this.layers[layerId] = new CanvasLayer(
                        `${layerId}Canvas`,
                        index + 1, //zindex
                        this.config
                    );
                });
            }

            /**
             * Apply configuration styles to elements
             */
            applyConfigStyles() {
                // Set canvas container dimensions
                const container = document.getElementById('canvas-container');
                container.style.width = `${this.config.canvas.width}px`;
                container.style.height = `${this.config.canvas.height}px`;

                // Apply language direction if specified
                if (this.config.direction === 'rtl') {
                    container.dir = 'rtl';
                    container.classList.add('rtl');
                }
            }

            /**
             * Currently unused
             * Clear all drawing layers
             */
            clearAll() {
                Object.values(this.layers).forEach(layer => layer.clear());
            }

            /**
             * Draw ruled lines based on configuration
             */
            drawRuledLines() {
                if (!this.config.rulePaper) {
                    this.layers.rule.clear();
                    return;
                }

                const ctx = this.layers.rule.context;
                const width = this.config.canvas.width;
                const height = this.config.canvas.height;

                // Clear canvas and set white background
                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = 'white';
                ctx.globalCompositeOperation = 'destination-over';
                ctx.fillRect(0, 0, width, height); 
                ctx.globalCompositeOperation = 'source-over';

                // Get line positions from config
                const lines = this.config.ruledLines || [
                    { y: 0.72, style: 'solid', color: '#000000', width: 2 },    // Bottom solid black
                    { y: 0.53, style: 'dashed', color: 'rgba(255,0,0,0.3)', width: 1 }, // Middle red
                    { y: 0.15, style: 'dashed', color: 'rgba(0,0,255,0.3)', width: 1 }  // Top blue
                ];

                // Draw each line
                lines.forEach(line => {
                    ctx.beginPath();
                    ctx.strokeStyle = line.color;
                    ctx.lineWidth = line.width;

                    if (line.style === 'dashed') {
                        ctx.setLineDash([5, 5]);
                    } else {
                        ctx.setLineDash([]);
                    }

                    const yPos = line.y * height;
                    ctx.moveTo(0, yPos);
                    ctx.lineTo(width, yPos);
                    ctx.stroke();
                });

                // Reset dash setting
                ctx.setLineDash([]);
            }

            /**
             * Display a printed letter on the background layer
             * @param {String} letterChar - Character to display
             */
            drawFontLetter(letterChar) {
                // console.log("temporarily dactivate drawing print letter. would have displayed: "+`${letterChar}`); return
                const ctx = this.layers.letter.context;
                const width = this.config.canvas.width;
                const height = this.config.canvas.height;

                ctx.clearRect(0, 0, width, height);

                // Apply letter style from config
                const letterStyle = this.config.letterStyle || {
                    font: 'bold 250px Arial',
                    color: '#DDDDDD',
                    align: 'center',
                    baseline: 'middle'
                };

                ctx.fillStyle = letterStyle.color;
                ctx.font = letterStyle.font;
                ctx.textAlign = letterStyle.align;
                ctx.textBaseline = letterStyle.baseline;

                // Draw the letter centered on the canvas
                ctx.fillText(letterChar, width / 2, height / 2);
            }

            /**
             * Draw guides for the current letter
             * @param {Letter} letter - The letter object to guide
             * @param {Number} currentStrokeIndex - Index of the current stroke
             */
            drawLetterGuide(letter, currentStrokeIndex) {
                const ctx = this.layers.guide.context;
                const width = this.config.canvas.width;
                const height = this.config.canvas.height;

                ctx.clearRect(0, 0, width, height);

                // Get styles from config
                const styles = this.config.styles;
                const completedStyle = styles.completed;
                const guideStyle = styles.guide;

                // Draw each stroke in order completed and next guides but skipping current for now
                letter.strokes.forEach((stroke, index) => {
                    if (index === currentStrokeIndex) return;
                    // Use highlight style for current stroke, guide style for others
                    const style = (index < currentStrokeIndex) ? completedStyle : guideStyle;

                    // Draw the stroke
                    stroke.draw(ctx, style); // style is applied in Stroke.draw
                    // TODO check if I am drawing completed separately anywhere?
                });

                // Draw current stroke
                if (currentStrokeIndex >= letter.strokes.length) {
                    return;
                } else {
                    const currStroke = letter.strokes[currentStrokeIndex];
                    // Draw the current stroke above
                    currStroke.draw(ctx, styles.highlight);

                    // Draw direction indicators for current stroke
                    this.drawStrokeDirections(currStroke, styles.arrow);

                    // Add start marker for the current stroke
                    this.drawStartMarker(ctx, currStroke);
                }

            }

            /**
             * Draw direction indicators for a stroke
             * @param {Stroke} stroke - The stroke to add directions to
             * @param {Object} arrowStyle - Style for the direction indicators
             */
            drawStrokeDirections(stroke, arrowStyle) {
                const ctx = this.layers.guide.context;

                // Set arrow style
                ctx.strokeStyle = arrowStyle.color;
                ctx.fillStyle = arrowStyle.color;
                ctx.lineWidth = arrowStyle.lineWidth;

                // Let the stroke draw its own directional indicators
                stroke.drawDirections(ctx, arrowStyle);
            }

            /**
             * Draws a circular marker at the start point of a stroke
             * This helps users identify where to begin drawing each stroke
             *
             * @param {CanvasRenderingContext2D} ctx - The canvas context to draw on
             * @param {Stroke} stroke - The stroke object (LineStroke, CurveStroke, or CompoundStroke)
             * @param {Object} [options] - Optional configuration for the marker
             * @param {string} [options.color='#FFA500'] - Color of the marker (default: orange)
             * @param {number} [options.radius=5] - Size of the marker in pixels
             * @param {number} [options.borderWidth=2] - Width of the marker's border
             * @param {string} [options.borderColor='#FFFFFF'] - Color of the marker's border
             */
            drawStartMarker(ctx, stroke, options = {}) {
                // Default options
                const markerOptions = {
                    color: options.color || '#FFA500',          // Orange by default
                    radius: options.radius || 5,                // 5px radius by default
                    borderWidth: options.borderWidth || 2,      // 2px border by default
                    borderColor: options.borderColor || '#FFFFFF' // White border by default
                };

                // Get the start point based on stroke type
                let startPoint;

                if (stroke.type === 'compound') {
                    // For compound strokes, get the first point of the first sub-stroke
                    if (stroke.subStrokes && stroke.subStrokes.length > 0) {
                        startPoint = this.getStrokeStartPoint(stroke.subStrokes[0]);
                    }
                } else {
                    // For simple line and curve strokes
                    startPoint = this.getStrokeStartPoint(stroke);
                }

                if (!startPoint) return; // Exit if no valid start point

                // Save current context state
                ctx.save();

                // Draw the filled circle
                ctx.beginPath();
                ctx.arc(startPoint.x, startPoint.y, markerOptions.radius, 0, Math.PI * 2);
                ctx.fillStyle = markerOptions.color;
                ctx.fill();

                // Draw the border
                if (markerOptions.borderWidth > 0) {
                    ctx.lineWidth = markerOptions.borderWidth;
                    ctx.strokeStyle = markerOptions.borderColor;
                    ctx.stroke();
                }

                // Restore context state
                ctx.restore();
            }

            /**
             * Helper method to get the start point of any stroke type. could be mad into a Stroke method
             *
             * @param {Stroke} stroke - The stroke to get the start point from
             * @returns {Point|null} The start point of the stroke or null if not found
             * @private
             */
            getStrokeStartPoint(stroke) {
                if (!stroke) return null;

                if (stroke.type === 'line' || stroke.type === 'curve') {
                    // For simple strokes, return the first point
                    return stroke.points && stroke.points.length > 0 ? stroke.points[0] : null;
                } else if (stroke.type === 'compound') {
                    // For compound strokes, recursively get the start point of the first sub-stroke
                    return stroke.subStrokes && stroke.subStrokes.length > 0
                        ? this.getStrokeStartPoint(stroke.subStrokes[0])
                        : null;
                }

                return null;
            }

            /**
             * Draw completed strokes
             * @param {Letter} letter - The letter object
             * @param {Number} completedIndex - Index up to which strokes are completed exclusive
             */
            drawCompletedStrokes(letter, completedIndex) {
                const ctx = this.layers.completed.context;
                const completeStyle = this.config.styles.completed;

                // Draw each completed stroke
                for (let i = 0; i < completedIndex; i++) {
                    const stroke = letter.strokes[i];

                    ctx.strokeStyle = completeStyle.color;
                    ctx.lineWidth = completeStyle.lineWidth;
                    ctx.lineCap = completeStyle.lineCap || 'round';

                    stroke.draw(ctx, completeStyle);
                }
            }

            /**
             * Draw the user's current input path
             * @param {Array} path - Array of points representing the user's drawing
             */
            drawUserPath(path) {
                if (path.length < 2) return;

                const ctx = this.layers.draw.context;
                const width = this.config.canvas.width;
                const height = this.config.canvas.height;

                // Clear the drawing layer
                ctx.clearRect(0, 0, width, height);

                // Get user drawing style from config
                const userStyle = this.config.styles.user || {
                    color: '#2196f3',
                    lineWidth: 20,
                    lineCap: 'round'
                };

                // Apply style
                ctx.strokeStyle = userStyle.color;
                ctx.lineWidth = userStyle.lineWidth;
                ctx.lineCap = userStyle.lineCap;

                // Draw the path
                ctx.beginPath();
                ctx.moveTo(path[0].x, path[0].y);

                for (let i = 1; i < path.length; i++) {
                    ctx.lineTo(path[i].x, path[i].y);
                }

                ctx.stroke();
            }

            /**
             * Animate a stroke being drawn
             * @param {Stroke} stroke - The stroke to animate
             * @param {Object} style - The style to apply
             * @param {Boolean} drawOver - Whether to draw over or inside the letter. Fill in combination rules
             * @returns {Promise} Resolves when animation completes
             */
            drawAnimatedStroke(stroke, style, progress, drawOver = false) {
                return new Promise(resolve => {
                    const ctx = this.layers.completed.context;
                    const letterCtx = this.layers.letter.context;
                    // Clear and reset
                    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                    // Draw the stroke with current progress
                    style.apply(ctx);
                    stroke.draw(ctx, style, progress);



                    // Store initial state - move to app
                    const originalComposite = ctx.globalCompositeOperation;

                    // Composite with letter
                    ctx.globalCompositeOperation = drawOver ?
                        'destination-over' : 'destination-in';

                    ctx.drawImage(letterCtx.canvas, 0, 0);
                    resolve();                 
                });
            }

            /**
             * Update the instruction text
             * @param {String} messageKey - Key of the message in the config
             * @param {String} color - Optional color override
             */
            updateInstruction(messageKey, color = null) {
                const message = this.config.ui[messageKey] || messageKey;
                this.elements.instruction.textContent = message;

                if (color) {
                    this.elements.instruction.style.color = color;
                } else {
                    // Reset to default color
                    this.elements.instruction.style.color = '#444';
                }
            }

            /**
             * Update the accuracy display
             * @param {Number} accuracy - Accuracy percentage (0-100)
             */
            updateAccuracy(accuracy) {
                if (accuracy === null) {
                    this.elements.accuracy.textContent = '';
                    return;
                }

                const formattedAccuracy = Math.round(accuracy);

                // Use configured accuracy text format
                const accuracyFormat = this.config.ui.accuracyFormat || 'Accuracy: {value}%';
                const message = accuracyFormat.replace('{value}', formattedAccuracy);

                this.elements.accuracy.textContent = message;

                // Optionally apply color based on accuracy
                if (this.config.accuracyColors) {
                    const colorThresholds = this.config.accuracyColors;
                    let color = '#666'; // Default color

                    for (const threshold in colorThresholds) {
                        if (formattedAccuracy >= Number(threshold)) {
                            color = colorThresholds[threshold];
                        }
                    }

                    this.elements.accuracy.style.color = color;
                }
            }

            /**
             * Add animated guiding arrow at a position
             * @param {Object} position - Position to add arrow
             */
            addGuideArrow(position) {
                // Create and add arrow element
                const arrow = document.createElement('div');
                arrow.className = 'arrow';
                arrow.style.left = `${position.x}px`;
                arrow.style.top = `${position.y}px`;

                // Add SVG arrow content based on config
                const arrowColor = this.config.styles.arrow.color || '#FFA500';
                arrow.innerHTML = `
                      <svg width="40" height="40" viewBox="0 0 40 40">
                        <path d="M20,5 L35,30 L20,25 L5,30 Z" fill="${arrowColor}" />
                      </svg>
                    `;

                // Add to container
                const container = document.getElementById('canvas-container');
                container.appendChild(arrow);

                // Remove after animation duration
                setTimeout(() => {
                    container.removeChild(arrow);
                }, 3000);
            }

            /**
             * Show a success animation
             */
            showSuccessAnimation() {
                // Optional success animation (confetti, stars, etc.)
                if (this.config.enableSuccessAnimation) {
                    // Simple example - add success class to container
                    const container = document.getElementById('canvas-container');
                    container.classList.add('success-animation');

                    setTimeout(() => {
                        container.classList.remove('success-animation');
                    }, 1500);
                }
            }

            /**
             * Animate a stroke drawing
             * @param {Stroke} stroke - Stroke to animate
             * @param {number} duration - Animation duration in milliseconds
             * @param {StrokeStyle} style - Style for how to draw
             * @param {boolean} drawOver - combine with character ie. fill or just draw stroke
             * @returns {Promise} Resolves when animation completes
             */
            animateStroke(stroke, duration, style, drawOver = false) {
                const ctx = this.layers.completed.context;
                const letterCtx = this.layers.letter.context;
                // Clear and reset
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                return new Promise(resolve => {
                    let startTime = null;

                    const animate = (timestamp) => {
                        if (!startTime) startTime = timestamp;
                        const progress = Math.min((timestamp - startTime) / duration, 1);

                        //this.clear();
                        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

                        // Draw the stroke at current progress
                        // await this?
                        this.drawAnimatedStroke(stroke, style, progress, drawOver);

                        if (progress < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            resolve();
                        }
                    };

                    requestAnimationFrame(animate);
                });
            }

        }


        // --- Controller ---
        /**
         * LetterDrawingApp: Main application controller. Main application class for letter drawing practice.
         * Manages the canvas layers, stroke data, user interaction, and drawing validation.
         * Handles multiple canvas layers for ruled paper, letter display, guides, and user drawing.
         */
        class LetterDrawingApp {
            constructor() {
                // Initialize the configuration system
                this.configLoader = new ConfigLoader();
                this.config = this.configLoader.getConfig();
                console.log(this.config);
                // Initialize state with default values
                this.state = {
                    currentChar: null, // char only. Will be set once data is loaded
                    currentStrokeIndex: 0,
                    isDrawing: false,
                    drawingPath: [], // will hold a string of points
                    isAutoDrawing: false,
                    completedStrokes: []
                };

                // Load language-specific letter data asynchronously
                this.configLoader.loadLetterData()
                    .then(letterData => {
                        this.letterData = this.processLetterData(letterData, this.config);
                        this.initializeApp();
                    })
                    .catch(error => {
                        console.error('Failed to initialize app:', error);
                        this.showErrorMessage('Failed to load letter data. Please try refreshing the page.');
                    });

            }

            /**
             * Process raw letter data into Letter objects
             */
            processLetterData(rawData, config) {
                const letterMap = new Map();
                for (const [key, data] of Object.entries(rawData)) {
                    letterMap.set(key, new Letter(config, key, {
                        strokes: data.strokes,
                        fontStrokes: data.fontStrokes || data.strokes
                    }));
                }

                return letterMap;
            }

            /**
             * Initialize the application once data is loaded
             */
            initializeApp() {
                // Create view with loaded configuration
                this.view = new LetterView(this.config);

                // Initialize now currentLetter
                this.state.currentChar = this.getInitialLetter();

                // Apply language-specific UI text
                this.updateUIText();

                // Set direction for RTL languages if needed
                if (this.config.direction === 'rtl') {
                    document.body.dir = 'rtl';
                    document.body.classList.add('rtl');
                }

                // Setup all event listeners
                this.setupEventListeners();
                
                // Initial render
                this.render();
                
                // Remove loading indicator if present
                const loadingIndicator = document.getElementById('loadingIndicator');
                if (loadingIndicator) {
                    loadingIndicator.style.display = 'none';
                }
                
            }

            /**
             * Get the initial letter to display
             */
            getInitialLetter() {
                // Try to get from URL or select the first available letter
                const urlParams = new URLSearchParams(window.location.search);
                const letterParam = urlParams.get('letter');

                if (letterParam && this.letterData.has(letterParam)) {
                    return letterParam;
                }

                // Default to first letter in the data
                return this.letterData.keys().next().value;
            }

            /**
             * Update all UI text elements with language-specific strings
             */
            updateUIText() {
                const { ui } = this.config;

                // Update page title and header
                document.title = ui.title;
                document.querySelector('h1').textContent = ui.title;

                // Update button labels
                document.getElementById('resetBtn').textContent = ui.resetButton;
                document.getElementById('autoDrawBtn').textContent = ui.autoDrawButton;
                document.getElementById('toggleRule').textContent = ui.toggleRuleButton;
                document.getElementById('nextLetterBtn').textContent = ui.nextLetterButton || 'Next Letter';
                document.getElementById('goToLetterBtn').textContent = ui.goButton || 'Go';

                const letterInput = document.getElementById('letterInput');
                if (letterInput) {
                    letterInput.placeholder = ui.letterInputPlaceholder || 'Type a letter';
                }

                // Update instruction text
                document.getElementById('instruction').textContent = ui.followStrokeMessage;

                // Populate letter selector with proper labels
                this.populateLetterSelector();
            }

            /**
             * Populate the letter selector dropdown
             */
            populateLetterSelector() {
                const select = document.getElementById('letterSelect');
                select.innerHTML = '';

                for (const letter of this.letterData.keys()) {
                    const option = document.createElement('option');
                    option.value = letter;
                    option.textContent = `${this.config.ui.letterPrefix || 'Letter'} ${letter}`;
                    select.appendChild(option);
                }

                select.value = this.state.currentChar;
            }

            /**
             * Set up all event listeners with proper binding
             */
            setupEventListeners() {
                // Bind all methods that will be used as event handlers
                this.handleStart = this.handleStart.bind(this);
                this.handleMove = this.handleMove.bind(this);
                this.handleEnd = this.handleEnd.bind(this);
                this.handleLetterChange = this.handleLetterChange.bind(this);
                this.reset = this.reset.bind(this);
                this.autoDraw = this.autoDraw.bind(this);
                this.toggleRuledPaper = this.toggleRuledPaper.bind(this);
                // new methods
                this.goToNextLetter = this.goToNextLetter.bind(this);
                this.handleLetterInput = this.handleLetterInput.bind(this);

                // Canvas event listeners
                const drawCanvas = this.view.layers.draw.canvas;

                // Mouse events
                drawCanvas.addEventListener('mousedown', this.handleStart);
                drawCanvas.addEventListener('mousemove', this.handleMove);
                drawCanvas.addEventListener('mouseup', this.handleEnd);
                drawCanvas.addEventListener('mouseout', this.handleEnd);

                // Touch events
                drawCanvas.addEventListener('touchstart', e => {
                    e.preventDefault();
                    this.handleStart(e);
                });

                drawCanvas.addEventListener('touchmove', e => {
                    e.preventDefault();
                    this.handleMove(e);
                });

                drawCanvas.addEventListener('touchend', this.handleEnd);

                // top canvas is draw
                const colors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'];
                const circleRadius = 10;
                let circleCount = 0;
                let colorIndex = 0;

                drawCanvas.addEventListener('dblclick', (event) => {
                    console.log('dblclick');
                    const ctx = drawCanvas.getContext('2d');
                    const x = event.offsetX;
                    const y = event.offsetY;
                    const color = colors[colorIndex % colors.length];

                    ctx.beginPath();
                    ctx.arc(x, y, circleRadius, 0, 2 * Math.PI);
                    ctx.fillStyle = color;
                    ctx.fill();

                    console.log(`Canvas ${drawCanvas.id} - Circle ${circleCount + 1}: Color: ${color}, X: ${x}, Y: ${y}`);

                    circleCount++;
                    colorIndex++;
                });


                // UI control events
                document.getElementById('letterSelect').addEventListener('change', this.handleLetterChange);
                document.getElementById('resetBtn').addEventListener('click', this.reset);
                document.getElementById('autoDrawBtn').addEventListener('click', this.autoDraw);
                document.getElementById('toggleRule').addEventListener('click', this.toggleRuledPaper);

                // Add event listeners for new controls
                const nextLetterBtn = document.getElementById('nextLetterBtn');
                if (nextLetterBtn) {
                    nextLetterBtn.addEventListener('click', this.goToNextLetter);
                }

                const letterInput = document.getElementById('letterInput');
                const goToLetterBtn = document.getElementById('goToLetterBtn');

                if (letterInput && goToLetterBtn) {
                    // Handle clicking the Go button
                    goToLetterBtn.addEventListener('click', this.handleLetterInput);

                    // Handle pressing Enter key in the input
                    letterInput.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            this.handleLetterInput();
                        }
                    });
                }
            }

            /**
             * Handle letter input from the text field
             */
            handleLetterInput() {
                const input = document.getElementById('letterInput');
                if (input) {
                    const char = input.value;
                    this.goToLetter(char);
                    // Clear the input after processing
                    input.value = '';
                }
            }

            /**
             * Handle the start of drawing (mousedown/touchstart)
             */
            handleStart(event) {
                if (this.state.isAutoDrawing) return;

                this.state.isDrawing = true;
                const startPt = Utils.getEventPoint(event, this.config);
                // this.view.layers[this.view.layers.length]
                // working on

                // console.log(this.view.layers); console.log(point);
                this.state.drawingPath = [startPt];

                // Clear accuracy display
                document.getElementById('accuracy').textContent = '';
            }

            /**
             * Handle drawing movement (mousemove/touchmove)
             */
            handleMove(event) {
                if (!this.state.isDrawing || this.state.isAutoDrawing) return;

                const point = Utils.getEventPoint(event, this.config);
                this.state.drawingPath.push(point);

                // Render the updated path
                this.view.drawUserPath(this.state.drawingPath);
            }

            /**
             * Handle the end of drawing (mouseup/touchend)
             */
            handleEnd() {
                if (!this.state.isDrawing || this.state.isAutoDrawing) return;
                this.state.isDrawing = false;

                // If there are no more strokes to complete, do nothing
                if (this.state.currentStrokeIndex >= this.getCurrentLetter().strokes.length) {
                    setTimeout(() => {
                        // Clear drawing canvas
                        this.view.layers.draw.clear();
                        this.state.drawingPath = [];
                    }, 1000);

                    return;
                }

                // Validate the stroke against the current expected stroke
                const currentStroke = this.getCurrentLetter().strokes[this.state.currentStrokeIndex];
                const accuracy = currentStroke.calculateAccuracy(this.state.drawingPath);

                // Display accuracy
                document.getElementById('accuracy').textContent =
                    `${this.config.ui.accuracyLabel || 'Accuracy'}: ${Math.round(accuracy)}%`;

                // Check if stroke passes accuracy threshold
                if (accuracy >= this.config.accuracy.threshold) {
                    this.nextStroke();
                }

                // Clear drawing canvas
                this.view.layers.draw.clear();
                this.state.drawingPath = [];
            }

            nextStroke() {
                // Mark stroke as completed
                this.state.completedStrokes.push(this.state.currentStrokeIndex);

                // Move to next stroke
                this.state.currentStrokeIndex++;

                // Draw the stroke in the completed layer
                // this.view.drawCompletedStrokes(this.getCurrentLetter(), this.state.currentStrokeIndex);

                // Update the guide display
                this.updateGuideDisplay();

                // Check if the letter is completed
                if (this.state.currentStrokeIndex >= this.getCurrentLetter().strokes.length) {
                    this.handleLetterCompletion();
                }
            }

            /**
             * Handle letter completion
             */
            handleLetterCompletion() {
                // Update instruction text with completion message
                const instructionEl = document.getElementById('instruction');
                instructionEl.textContent = this.config.ui.completedMessage;
                instructionEl.style.color = '#4CAF50';

                // Optional: show a celebration animation or play a success sound
                if (this.config.enableCelebration) {
                    this.showCelebration();
                }

                // TODO switch the drawing action to being confetti and switch back when no longer complete
            }

            /**
             * Handle letter selection change
             */
            handleLetterChange(event) {
                this.state.currentChar = event.target.value;
                this.reset();
            }

            /**
             * Toggle ruled paper display
             */
            toggleRuledPaper() {
                this.config.rulePaper = !this.config.rulePaper;
                this.view.drawRuledLines(this.config.rulePaper);
            }

            /**
             * Reset the current letter practice
             */
            reset() {
                // Reset state
                this.state.currentStrokeIndex = 0;
                this.state.completedStrokes = [];
                this.state.drawingPath = [];

                // Reset instruction text
                const instructionEl = document.getElementById('instruction');
                instructionEl.textContent = this.config.ui.followStrokeMessage;
                instructionEl.style.color = '#444';

                // Clear accuracy display
                document.getElementById('accuracy').textContent = '';

                // Clear all drawing layers
                this.view.layers.completed.clear(); // ['rule', 'letter', 'completed', 'guide', 'draw']
                this.view.layers.guide.clear();
                this.view.layers.draw.clear();

                // Redraw the letter guide
                this.render();
            }

            /**
             * Automatically draw the current letter.
             */
            async autoDraw() {
                console.log('autoDraw');
                if (this.state.isAutoDrawing) return;


                // Set auto-drawing state
                this.state.isAutoDrawing = true;
                console.log('isAutoDrawing');

                // Disable controls during animation
                this.setControlsEnabled(false); 

                // Save the current state before auto drawing
                //const previousState = {
                //    currentStrokeIndex: this.state.currentStrokeIndex,
                //    completedStrokes: [...this.state.completedStrokes]
                //};
                const previousState = {...this.state};

                // Reset to start fresh
                this.reset();

                // Get the letter to draw
                const letter = this.getCurrentLetter();
                // const strokesToDraw = letter.fontStrokes || letter.strokes;
                const strokesToDraw = letter.strokes; // simplify for now

                // Draw each stroke with animation
                for (let i = 0; i < strokesToDraw.length; i++) {
                    const stroke = strokesToDraw[i];
                    await this.view.animateStroke(stroke, this.config.animation.duration, this.config.styles.completed); // HERE
                    
                    // Short pause between strokes
                    await new Promise(resolve => setTimeout(resolve, 300));
                }

                // Wait a moment before resetting
                await new Promise(resolve => setTimeout(resolve, 2000));

                // Reset and restore previous state if needed
                this.reset();

                if (previousState.currentStrokeIndex > 0) {
                    // Restore completed strokes
                    //this.state.currentStrokeIndex = previousState.currentStrokeIndex;
                    //this.state.completedStrokes = previousState.completedStrokes;
                    this.state = { ...previousState };

                    // Redraw completed strokes
                    this.view.drawCompletedStrokes(this.getCurrentLetter(), this.state.currentStrokeIndex);


                    // Update guide display
                    this.updateGuideDisplay();
                }

                // Re-enable controls
                this.setControlsEnabled(true);
                this.state.isAutoDrawing = false;
            }

            /**
             * Update the guide display based on current state
             */
            updateGuideDisplay() {
                const letter = this.getCurrentLetter();
                this.view.drawLetterGuide(letter, this.state.currentStrokeIndex);
            }

            /**
             * Enable or disable all UI controls
             */
            setControlsEnabled(enabled) {
                const controls = [
                    document.getElementById('letterSelect'),
                    document.getElementById('resetBtn'),
                    document.getElementById('autoDrawBtn'),
                    document.getElementById('toggleRule')
                ];

                controls.forEach(control => {
                    if (control) control.disabled = !enabled;
                });
            }

            /**
             * Show an error message to the user
             */
            showErrorMessage(message) {
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error-message';
                errorDiv.textContent = message;

                document.body.appendChild(errorDiv);

                // Auto-remove after 5 seconds
                setTimeout(() => {
                    errorDiv.remove();
                }, 5000);
            }

            /**
             * Show a celebration animation
             */
            showCelebration() {
                // Implementation for showing celebration effect
                // Could be confetti, animation, etc.
            }

            /**
             * Get the current letter object
             */
            getCurrentLetter() {
                return this.letterData.get(this.state.currentChar);
            }
            /**
             * Navigate to the next letter in the dropdown
             * Loops back to the first letter if at the end
             */
            goToNextLetter() {
                const select = document.getElementById('letterSelect');
                const currentIndex = select.selectedIndex;

                // Calculate next index, looping back to 0 if at the end
                const nextIndex = (currentIndex + 1) % select.options.length;

                // Set the new selection
                select.selectedIndex = nextIndex;

                // Update the current letter and reset
                this.state.currentChar = select.value;
                this.reset();

                // Provide feedback to the user
                this.view.updateInstruction(`Switched to ${this.state.currentChar}`, '#2196f3');
                setTimeout(() => {
                    this.view.updateInstruction(this.config.ui.followStrokeMessage);
                }, 1500);
            }

            /**
             * Navigate to a specific letter by character
             * @param {string} char - The character to navigate to
             * @returns {boolean} - True if successful, false if letter not found
             */
            goToLetter(char) {
                if (!char) return false;

                // Normalize the input (in case it's uppercase but we store lowercase, etc.)
                const normalizedChar = char.trim();
                if (normalizedChar.length === 0) return false;

                // Check if this letter exists in our data
                if (this.letterData.has(normalizedChar)) {
                    this.state.currentChar = normalizedChar;

                    // Update the dropdown to match
                    const select = document.getElementById('letterSelect');
                    for (let i = 0; i < select.options.length; i++) {
                        if (select.options[i].value === normalizedChar) {
                            select.selectedIndex = i;
                            break;
                        }
                    }

                    // Reset and start practicing this letter
                    this.reset();

                    // Provide feedback
                    this.view.updateInstruction(`Switched to letter ${normalizedChar}`, '#2196f3');
                    setTimeout(() => {
                        this.view.updateInstruction(this.config.ui.followStrokeMessage);
                    }, 1500);

                    return true;
                } else {
                    // Letter not found, provide feedback
                    this.view.updateInstruction(`Letter "${normalizedChar}" not found`, '#e74c3c');
                    setTimeout(() => {
                        this.view.updateInstruction(this.config.ui.followStrokeMessage);
                    }, 2000);

                    return false;
                }
            }
            /**
             * Main render method
             */
            render() {
                console.log("Rendering called");
                // Draw ruled paper if enabled
                this.view.drawRuledLines(this.config.rulePaper);

                // Draw font letter
                const letter = this.getCurrentLetter();
                this.view.drawFontLetter(letter.character);

                // Draw guide with current stroke highlighted
                console.log("About to draw letter guide");
                this.view.drawLetterGuide(letter, this.state.currentStrokeIndex);
            }
        }

        var app;
        // --- Initialize the application ---
        document.addEventListener('DOMContentLoaded', () => {
            app = new LetterDrawingApp();
        });


        //--- Bezier addition
        if (true) { 
        /**
         * BezierEditor - A module to add and manipulate Bezier control points
         * Allows placing control points on the canvas and updating a Bezier curve by dragging them
         */
        class BezierEditor {
            /**
             * Create a new BezierEditor
             * @param {LetterDrawingApp} app - The main application instance
             * @param {CanvasLayer} targetLayer - The canvas layer to draw on
             */
            constructor(app) {
                this.app = app;
                this.targetLayer = app.view.layers.draw; // Using the drawing layer
                this.controlPoints = []; // Array to store control points
                this.isDragging = false;
                this.selectedPointIndex = -1;
                this.isActive = false;
                this.pointRadius = 8;
                this.previewLayer = app.view.layers.guide; // Use guide layer for preview
                this.canvasSize = 300; // Default canvas size for fraction calculations

                // Colors for different types of points
                this.colors = {
                    endpoint: '#3498db', // Blue for start/end points
                    controlPoint: '#e74c3c', // Red for control points
                    line: '#95a5a6', // Gray for connecting lines
                    curve: '#2ecc71' // Green for the Bezier curve
                };

                // Input control panel
                this.controlPanel = null;

                // Bind methods
                this.handleMouseDown = this.handleMouseDown.bind(this);
                this.handleMouseMove = this.handleMouseMove.bind(this);
                this.handleMouseUp = this.handleMouseUp.bind(this);
                this.toggleActive = this.toggleActive.bind(this);
                this.render = this.render.bind(this);
                this.updateFromInputs = this.updateFromInputs.bind(this);
            }

            /**
             * Initialize the editor
             */
            initialize() {
                // Create the UI button
                this.createButton();

                // Add save button
                this.addSaveButton();

                // Add reset button
                this.addResetButton();

                // Create control panel for inputs
                this.createControlPanel();

                // Ensure we start with a clean state
                this.clearPoints();
            }

            /**
             * Add a reset button for the bezier editor
             */
            addResetButton() {
                const controlsContainer = document.querySelector('.controls');

                const resetButton = document.createElement('button');
                resetButton.id = 'resetBezierBtn';
                resetButton.textContent = 'Reset Bezier';
                resetButton.style.display = 'none'; // Initially hidden

                resetButton.addEventListener('click', () => {
                    this.clearPoints();
                    this.render();
                });

                controlsContainer.appendChild(resetButton);
                this.resetButton = resetButton;
            }

            /**
             * Create the UI button for the Bezier editor
             */
            createButton() {
                const controlsContainer = document.querySelector('.controls');

                this.editorButton = document.createElement('button');
                this.editorButton.id = 'bezierEditorBtn';
                this.editorButton.textContent = 'Bezier Editor';
                this.editorButton.addEventListener('click', this.toggleActive);

                controlsContainer.appendChild(this.editorButton);
            }

            /**
             * Create input control panel for precise point positioning
             */
            createControlPanel() {
                // Create control panel container
                this.controlPanel = document.createElement('div');
                this.controlPanel.id = 'bezierControlPanel';
                this.controlPanel.className = 'bezier-control-panel';
                this.controlPanel.style.display = 'none';

                // Create input fields for all 4 points (x,y coordinates)
                const pointLabels = ['Start Point', 'Control Point 1', 'Control Point 2', 'End Point'];

                for (let i = 0; i < 4; i++) {
                    const pointContainer = document.createElement('div');
                    pointContainer.className = 'point-controls';

                    // Add label
                    const label = document.createElement('div');
                    label.className = 'point-label';
                    label.innerHTML = `<strong>${pointLabels[i]} (${i}):</strong>`;
                    pointContainer.appendChild(label);

                    // Add X input with fraction display
                    const xContainer = document.createElement('div');
                    xContainer.className = 'coord-container';

                    const xLabel = document.createElement('span');
                    xLabel.textContent = 'X:';
                    xContainer.appendChild(xLabel);

                    const xInput = document.createElement('input');
                    xInput.type = 'number';
                    xInput.min = '0';
                    xInput.max = this.canvasSize.toString();
                    xInput.id = `point${i}X`;
                    xInput.className = 'coord-input';
                    xInput.placeholder = 'X';
                    xInput.addEventListener('change', this.updateFromInputs);
                    xContainer.appendChild(xInput);

                    const xFraction = document.createElement('span');
                    xFraction.id = `point${i}XFraction`;
                    xFraction.className = 'fraction-display';
                    xContainer.appendChild(xFraction);

                    pointContainer.appendChild(xContainer);

                    // Add Y input with fraction display
                    const yContainer = document.createElement('div');
                    yContainer.className = 'coord-container';

                    const yLabel = document.createElement('span');
                    yLabel.textContent = 'Y:';
                    yContainer.appendChild(yLabel);

                    const yInput = document.createElement('input');
                    yInput.type = 'number';
                    yInput.min = '0';
                    yInput.max = this.canvasSize.toString();
                    yInput.id = `point${i}Y`;
                    yInput.className = 'coord-input';
                    yInput.placeholder = 'Y';
                    yInput.addEventListener('change', this.updateFromInputs);
                    yContainer.appendChild(yInput);

                    const yFraction = document.createElement('span');
                    yFraction.id = `point${i}YFraction`;
                    yFraction.className = 'fraction-display';
                    yContainer.appendChild(yFraction);

                    pointContainer.appendChild(yContainer);

                    // Add color indicator
                    const colorIndicator = document.createElement('div');
                    colorIndicator.className = 'color-indicator';
                    colorIndicator.style.backgroundColor = i === 0 || i === 3 ? this.colors.endpoint : this.colors.controlPoint;
                    pointContainer.appendChild(colorIndicator);

                    this.controlPanel.appendChild(pointContainer);
                }

                // Add styles for the control panel
                const style = document.createElement('style');
                style.textContent = `
                .bezier-control-panel {
                    background-color: #f8f9fa;
                    border: 1px solid #ddd;
                    border-radius: 5px;
                    padding: 15px;
                    margin: 10px auto;
                    width: 90%;
                    max-width: 500px;
                    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
                }
                .point-controls {
                    display: flex;
                    flex-wrap: wrap;
                    align-items: center;
                    margin-bottom: 10px;
                    padding: 8px;
                    border-radius: 4px;
                    background-color: #fff;
                    border-left: 3px solid #ddd;
                }
                .point-label {
                    width: 100%;
                    margin-bottom: 5px;
                }
                .coord-container {
                    display: flex;
                    align-items: center;
                    margin-right: 15px;
                }
                .coord-input {
                    width: 60px;
                    margin: 0 5px;
                    padding: 5px;
                    border: 1px solid #ccc;
                    border-radius: 3px;
                }
                .fraction-display {
                    min-width: 60px;
                    color: #666;
                    font-family: monospace;
                }
                .color-indicator {
                    width: 15px;
                    height: 15px;
                    border-radius: 50%;
                    margin-left: auto;
                }
            `;
                document.head.appendChild(style);

                // Add to the DOM
                document.body.appendChild(this.controlPanel);
            }

            /**
             * Update control points from input values
             */
            updateFromInputs() {
                // Only process if we're active
                if (!this.isActive) return;

                // Create/update control points array as needed
                for (let i = 0; i < 4; i++) {
                    const xInput = document.getElementById(`point${i}X`);
                    const yInput = document.getElementById(`point${i}Y`);

                    if (xInput && yInput && xInput.value && yInput.value) {
                        const x = parseFloat(xInput.value);
                        const y = parseFloat(yInput.value);

                        if (!isNaN(x) && !isNaN(y)) {
                            // Create point if it doesn't exist
                            if (i >= this.controlPoints.length) {
                                this.controlPoints.push(new Point(x, y, this.app.config, false));
                            } else {
                                // Update existing point
                                this.controlPoints[i] = new Point(x, y, this.app.config, false);
                            }
                        }
                    }
                }

                // Update the display
                this.render();

                // Update instruction based on number of points
                if (this.controlPoints.length === 4) {
                    this.app.view.updateInstruction('Bezier curve updated from input values', '#27ae60');
                }
            }

            /**
             * Update input fields based on current control points
             */
            updateInputFields() {
                for (let i = 0; i < this.controlPoints.length; i++) {
                    const point = this.controlPoints[i];
                    const xInput = document.getElementById(`point${i}X`);
                    const yInput = document.getElementById(`point${i}Y`);
                    const xFraction = document.getElementById(`point${i}XFraction`);
                    const yFraction = document.getElementById(`point${i}YFraction`);

                    if (xInput && yInput) {
                        xInput.value = Math.round(point.x);
                        yInput.value = Math.round(point.y);
                    }

                    if (xFraction && yFraction) {
                        xFraction.textContent = this.toFractionString(point.x);
                        yFraction.textContent = this.toFractionString(point.y);
                    }
                }

                // Clear any unused input fields
                for (let i = this.controlPoints.length; i < 4; i++) {
                    const xInput = document.getElementById(`point${i}X`);
                    const yInput = document.getElementById(`point${i}Y`);
                    const xFraction = document.getElementById(`point${i}XFraction`);
                    const yFraction = document.getElementById(`point${i}YFraction`);

                    if (xInput && yInput) {
                        xInput.value = '';
                        yInput.value = '';
                    }

                    if (xFraction && yFraction) {
                        xFraction.textContent = '';
                        yFraction.textContent = '';
                    }
                }
            }

            /**
             * Toggle the editor active state
             */
            toggleActive() {
                this.isActive = !this.isActive;

                if (this.isActive) {
                    // Update button appearance
                    this.editorButton.style.backgroundColor = '#2980b9';
                    this.editorButton.style.color = 'white';

                    // Show reset button
                    if (this.resetButton) {
                        this.resetButton.style.display = 'inline-block';
                    }

                    // Show save button
                    document.getElementById('saveBezierBtn').style.display = 'inline-block';

                    // Show control panel
                    this.controlPanel.style.display = 'block';

                    // Add our event listeners
                    this.addEventListeners();

                    // Store the original drawing handlers before disabling them
                    this.savedHandleStart = this.app.handleStart;
                    this.savedHandleMove = this.app.handleMove;
                    this.savedHandleEnd = this.app.handleEnd;

                    // Replace with empty functions to disable regular drawing
                    this.app.handleStart = () => { };
                    this.app.handleMove = () => { };
                    this.app.handleEnd = () => { };

                    // Show instruction
                    this.app.view.updateInstruction('Click to add control points for Bezier curve', '#2980b9');

                    // Clear existing strokes to make room for our editor
                    this.app.view.layers.draw.clear();
                } else {
                    // Restore button appearance
                    this.editorButton.style.backgroundColor = '';
                    this.editorButton.style.color = '';

                    // Hide reset button
                    if (this.resetButton) {
                        this.resetButton.style.display = 'none';
                    }

                    // Hide save button
                    document.getElementById('saveBezierBtn').style.display = 'none';

                    // Hide control panel
                    this.controlPanel.style.display = 'none';

                    // Remove our event listeners
                    this.removeEventListeners();

                    // Restore original drawing handlers
                    if (this.savedHandleStart) {
                        this.app.handleStart = this.savedHandleStart;
                        this.app.handleMove = this.savedHandleMove;
                        this.app.handleEnd = this.savedHandleEnd;

                        // Nullify saved handlers to prevent memory leaks
                        this.savedHandleStart = null;
                        this.savedHandleMove = null;
                        this.savedHandleEnd = null;
                    }

                    // Clear points
                    this.clearPoints();

                    // Reset cursor
                    this.targetLayer.canvas.style.cursor = 'default';

                    // Restore original instruction
                    this.app.view.updateInstruction(this.app.config.ui.followStrokeMessage);
                }
            }

            /**
             * Convert decimal value to simplified fraction string relative to canvas size
             * @param {number} value - The pixel value to convert
             * @returns {string} - Simplified fraction as a string
             */
            toFractionString(value) {
                // Function to find greatest common divisor
                const gcd = (a, b) => b ? gcd(b, a % b) : a;

                // Round to nearest integer for better fractions
                const pixelValue = Math.round(value);

                // Handle special cases
                if (pixelValue === 0) return '0';
                if (pixelValue === this.canvasSize) return '1';

                // Find GCD for simplification
                const divisor = gcd(pixelValue, this.canvasSize);

                // Simplify the fraction
                const numerator = pixelValue / divisor;
                const denominator = this.canvasSize / divisor;

                // Return fraction string
                return `${numerator}/${denominator}`;
            }

            /**
             * Add event listeners for the editor
             */
            addEventListeners() {
                const canvas = this.targetLayer.canvas;
                canvas.addEventListener('mousedown', this.handleMouseDown);
                canvas.addEventListener('mousemove', this.handleMouseMove);
                canvas.addEventListener('mouseup', this.handleMouseUp);

                // Also add touch events
                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const mouseEvent = new MouseEvent('mousedown', {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                    this.handleMouseDown(mouseEvent);
                });

                canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const mouseEvent = new MouseEvent('mousemove', {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                    this.handleMouseMove(mouseEvent);
                });

                canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.handleMouseUp();
                });
            }

            /**
             * Remove event listeners
             */
            removeEventListeners() {
                const canvas = this.targetLayer.canvas;
                canvas.removeEventListener('mousedown', this.handleMouseDown);
                canvas.removeEventListener('mousemove', this.handleMouseMove);
                canvas.removeEventListener('mouseup', this.handleMouseUp);

                // Remove touch events
                canvas.removeEventListener('touchstart', this.handleMouseDown);
                canvas.removeEventListener('touchmove', this.handleMouseMove);
                canvas.removeEventListener('touchend', this.handleMouseUp);
            }

            /**
             * Handle mouse down event for adding or selecting control points
             * @param {MouseEvent} event - The mouse event
             */
            handleMouseDown(event) {
                if (!this.isActive) return;

                const point = Utils.getEventPoint(event, this.app.config);

                // Check if clicking on an existing point
                for (let i = 0; i < this.controlPoints.length; i++) {
                    const cp = this.controlPoints[i];
                    const distance = Math.hypot(point.x - cp.x, point.y - cp.y);

                    if (distance <= this.pointRadius) {
                        this.isDragging = true;
                        this.selectedPointIndex = i;
                        return;
                    }
                }

                // If not dragging and we have less than 4 points, add a new point
                if (this.controlPoints.length < 4) {
                    // Create a Point object
                    const newPoint = new Point(
                        point.x,
                        point.y,
                        this.app.config,
                        false // Not normalized
                    );

                    this.controlPoints.push(newPoint);

                    // Update input fields
                    this.updateInputFields();

                    // Render the updated points
                    this.render();

                    // Update instruction based on number of points
                    const pointsLeft = 4 - this.controlPoints.length;
                    if (pointsLeft > 0) {
                        this.app.view.updateInstruction(
                            `Added point ${this.controlPoints.length}. Add ${pointsLeft} more point${pointsLeft !== 1 ? 's' : ''}`,
                            '#3498db'
                        );
                    } else {
                        // We have all 4 points
                        this.app.view.updateInstruction('Drag points to adjust Bezier curve', '#27ae60');
                    }
                }
            }

            /**
             * Handle mouse move for dragging control points
             * @param {MouseEvent} event - The mouse event
             */
            handleMouseMove(event) {
                if (!this.isActive) return;

                // Update cursor if hovering over a point
                if (!this.isDragging) {
                    const point = Utils.getEventPoint(event, this.app.config);
                    let overPoint = false;

                    for (let i = 0; i < this.controlPoints.length; i++) {
                        const cp = this.controlPoints[i];
                        const distance = Math.hypot(point.x - cp.x, point.y - cp.y);

                        if (distance <= this.pointRadius) {
                            this.targetLayer.canvas.style.cursor = 'move';
                            overPoint = true;
                            break;
                        }
                    }

                    if (!overPoint) {
                        this.targetLayer.canvas.style.cursor = 'default';
                    }
                }

                // Handle dragging
                if (this.isDragging && this.selectedPointIndex !== -1) {
                    const point = Utils.getEventPoint(event, this.app.config);

                    // Update the point position
                    this.controlPoints[this.selectedPointIndex] = new Point(
                        point.x,
                        point.y,
                        this.app.config,
                        false // Not normalized
                    );

                    // Update input fields to match new position
                    this.updateInputFields();

                    // Redraw everything
                    this.render();
                }
            }

            /**
             * Handle mouse up to end dragging
             */
            handleMouseUp() {
                this.isDragging = false;
                this.selectedPointIndex = -1;
            }

            /**
             * Render the control points and Bezier curve
             */
            render() {
                // Clear both layers
                this.targetLayer.clear();
                this.previewLayer.clear();

                const ctx = this.targetLayer.context;
                const previewCtx = this.previewLayer.context;

                // Draw Bezier curve if we have all 4 points (on preview layer)
                if (this.controlPoints.length === 4) {
                    const [p0, p1, p2, p3] = this.controlPoints;

                    previewCtx.beginPath();
                    previewCtx.strokeStyle = this.colors.curve;
                    previewCtx.lineWidth = 3;
                    previewCtx.lineCap = 'round';

                    previewCtx.moveTo(p0.x, p0.y);
                    previewCtx.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
                    previewCtx.stroke();

                    // Show the curve data
                    this.displayCurveData();
                }

                // Draw connecting lines between points (on target layer)
                if (this.controlPoints.length >= 2) {
                    ctx.beginPath();
                    ctx.strokeStyle = this.colors.line;
                    ctx.lineWidth = 1;

                    // Draw lines between control points
                    for (let i = 0; i < this.controlPoints.length - 1; i++) {
                        ctx.moveTo(this.controlPoints[i].x, this.controlPoints[i].y);
                        ctx.lineTo(this.controlPoints[i + 1].x, this.controlPoints[i + 1].y);
                    }

                    ctx.stroke();
                }

                // Draw the control points (on top of everything)
                for (let i = 0; i < this.controlPoints.length; i++) {
                    const point = this.controlPoints[i];

                    // Choose color based on point type (endpoint or control point)
                    const isEndpoint = i === 0 || i === 3;
                    const color = isEndpoint ? this.colors.endpoint : this.colors.controlPoint;

                    // Draw the point with a border
                    ctx.beginPath();
                    ctx.fillStyle = color;
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.arc(point.x, point.y, this.pointRadius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();

                    // Draw the index
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(i.toString(), point.x, point.y);
                }
            }

            /**
             * Display normalized curve data with fractions
             */
            displayCurveData() {
                // Only display data when we have all 4 points
                if (this.controlPoints.length !== 4) {
                    // Show a helpful message about how many more points are needed
                    const accuracyEl = document.getElementById('accuracy');
                    const remaining = 4 - this.controlPoints.length;
                    accuracyEl.textContent = `Add ${remaining} more point${remaining !== 1 ? 's' : ''} to complete the Bezier curve`;
                    return;
                }

                // Convert to fractions for display
                const fractionPoints = this.controlPoints.map(point => {
                    return {
                        x: this.toFractionString(point.x),
                        y: this.toFractionString(point.y)
                    };
                });

                // Show in accuracy display area
                const accuracyEl = document.getElementById('accuracy');
                const controlPoints = this.controlPoints;
                //        accuracyEl.innerHTML = `Bezier points (as fractions): [
                //    {x: ${fractionPoints[0].x}, y: ${fractionPoints[0].y}},
                //    {x: ${fractionPoints[1].x}, y: ${fractionPoints[1].y}},
                //    {x: ${fractionPoints[2].x}, y: ${fractionPoints[2].y}},
                //    {x: ${fractionPoints[3].x}, y: ${fractionPoints[3].y}}
                //]`;
                accuracyEl.innerHTML = `Bezier points (unsimplified): <br><span>[
                {x: ${controlPoints[0].x}/300, y: ${controlPoints[0].y}/300},
                {x: ${controlPoints[1].x}/300, y: ${controlPoints[1].y}/300},
                {x: ${controlPoints[2].x}/300, y: ${controlPoints[2].y}/300},
                {x: ${controlPoints[3].x}/300, y: ${controlPoints[3].y}/300}
            ]</span>`;

                // Also log to console with both decimal and fraction formats
                console.log('Bezier curve data:');

                // Normalized decimals (original format)
                const normalizedPoints = this.controlPoints.map(point => {
                    return {
                        x: (point.x / this.canvasSize).toFixed(3),
                        y: (point.y / this.canvasSize).toFixed(3)
                    };
                });

                console.log('Normalized decimal format:');
                console.log(JSON.stringify({
                    type: 'curve',
                    points: [
                        { x: normalizedPoints[0].x, y: normalizedPoints[0].y },
                        { x: normalizedPoints[1].x, y: normalizedPoints[1].y },
                        { x: normalizedPoints[2].x, y: normalizedPoints[2].y },
                        { x: normalizedPoints[3].x, y: normalizedPoints[3].y }
                    ]
                }, null, 2));

                // Fraction format
                console.log('Fraction format:');
                console.log(JSON.stringify({
                    type: 'curve',
                    points: [
                        { x: fractionPoints[0].x, y: fractionPoints[0].y },
                        { x: fractionPoints[1].x, y: fractionPoints[1].y },
                        { x: fractionPoints[2].x, y: fractionPoints[2].y },
                        { x: fractionPoints[3].x, y: fractionPoints[3].y }
                    ]
                }, null, 2));
            }

            /**
             * Create a stroke object from the current Bezier curve
             * @returns {CurveStroke|null} - A new CurveStroke object or null if not enough points
             */
            createStroke() {
                if (this.controlPoints.length !== 4) return null;

                // Normalize the points for storage
                const normalizedPoints = this.controlPoints.map(point => {
                    return {
                        x: point.x / this.canvasSize,
                        y: point.y / this.canvasSize
                    };
                });

                // Create a stroke data object
                const strokeData = {
                    type: 'curve',
                    points: normalizedPoints
                };

                // Create and return a new CurveStroke
                return new CurveStroke(this.app.config, strokeData);
            }

            /**
             * Export the current Bezier curve as stroke data
             * @returns {Object|null} - Stroke data object or null if not enough points
             */
            exportStrokeData() {
                if (this.controlPoints.length !== 4) return null;

                // Normalize the points for storage
                const normalizedPoints = this.controlPoints.map(point => {
                    return {
                        x: point.x / this.canvasSize,
                        y: point.y / this.canvasSize
                    };
                });

                // Create a stroke data object
                return {
                    type: 'curve',
                    points: normalizedPoints
                };
            }

            /**
             * Import stroke data and set up control points
             * @param {Object} strokeData - The stroke data to import
             */
            importStrokeData(strokeData) {
                if (strokeData.type !== 'curve' || !strokeData.points || strokeData.points.length !== 4) {
                    console.error('Invalid stroke data for Bezier curve');
                    return;
                }

                // Convert normalized points to canvas coordinates
                this.controlPoints = strokeData.points.map(point => {
                    return new Point(
                        point.x * this.canvasSize,
                        point.y * this.canvasSize,
                        this.app.config,
                        false // Not normalized
                    );
                });

                // Update input fields
                this.updateInputFields();

                // Render the updated control points
                this.render();
            }

            /**
             * Clear all control points
             */
            clearPoints() {
                this.controlPoints = [];
                this.targetLayer.clear();
                this.previewLayer.clear();
                this.isDragging = false;
                this.selectedPointIndex = -1;

                // Clear input fields
                this.updateInputFields();

                // Reset the cursor
                this.targetLayer.canvas.style.cursor = 'default';

                // Clear the data display
                const accuracyEl = document.getElementById('accuracy');
                if (accuracyEl) accuracyEl.textContent = '';

                // If editor is active, update instruction
                if (this.isActive) {
                    this.app.view.updateInstruction('Click to add control points for Bezier curve', '#2980b9');
                }
            }

            /**
                 * Add a button to save the current Bezier as a stroke
                 */
            addSaveButton() {
                const controlsContainer = document.querySelector('.controls');

                const saveButton = document.createElement('button');
                saveButton.id = 'saveBezierBtn';
                saveButton.textContent = 'Save Bezier';
                saveButton.style.display = 'none'; // Initially hidden

                saveButton.addEventListener('click', () => {
                    const strokeData = this.exportStrokeData();
                    if (strokeData) {
                        // Display in console as both decimal and fraction formats
                        this.displayCurveData();
                        this.app.view.updateInstruction('Bezier data saved to console', '#2ecc71');

                        // Create a formatted output to show in a modal if needed
                        const fractionPoints = this.controlPoints.map(point => {
                            return {
                                x: this.toFractionString(point.x),
                                y: this.toFractionString(point.y)
                            };
                        });

                        const formattedOutput = JSON.stringify({
                            type: 'curve',
                            points: [
                                { x: fractionPoints[0].x, y: fractionPoints[0].y },
                                { x: fractionPoints[1].x, y: fractionPoints[1].y },
                                { x: fractionPoints[2].x, y: fractionPoints[2].y },
                                { x: fractionPoints[3].x, y: fractionPoints[3].y }
                            ]
                        }, null, 2);

                        // Show a success message
                        alert("Bezier curve data saved to console in both decimal and fraction formats!");

                        setTimeout(() => {
                            if (this.isActive) {
                                this.app.view.updateInstruction('Drag points to adjust Bezier curve', '#27ae60');
                            }
                        }, 2000);
                    } else {
                        this.app.view.updateInstruction('Please add 4 control points first', '#e74c3c');
                        setTimeout(() => {
                            this.app.view.updateInstruction('Click to add control points for Bezier curve', '#2980b9');
                        }, 2000);
                    }
                });

                controlsContainer.appendChild(saveButton);
            }
        }

        /**
        * Initialize the BezierEditor when the app is ready
        */
        document.addEventListener('DOMContentLoaded', () => {
            // Wait for the app to be fully initialized
            const initEditor = () => {
                if (app && app.view) {
                    const bezierEditor = new BezierEditor(app);
                    bezierEditor.initialize();

                    // Expose the editor for debugging
                    window.bezierEditor = bezierEditor;
                } else {
                    // Try again in a bit if app isn't ready
                    setTimeout(initEditor, 100);
                }
            };

            // Start checking for app initialization
            setTimeout(initEditor, 500);
        });
        }
    </script>


</body>
</html>