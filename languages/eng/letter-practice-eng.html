<!DOCTYPE html>
<html>
<head>
    <title>Letter Drawing Practice</title>
    <style>
        /* Container styles */
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        
        /* Canvas container with relative positioning for layering */
        #canvas-container {
            position: relative;
            width: 300px;
            height: 300px;
        }
        
        /* Canvas layers stacked using z-index */
        canvas {
            position: absolute;
            border: 1px solid #ccc;
            touch-action: none; /* Prevents default touch actions on mobile */
        }
        #ruleCanvas { z-index: 1; } /* Bottom layer: ruled paper */
        #completedCanvas { z-index: 3; } /* completed strokes */
        #letterCanvas { z-index: 2; } /* second to bottom layer: font letter */
        #guideCanvas { z-index: 4; }     /* Middle layer: guide strokes */
        #drawCanvas { z-index: 5; }      /* Top layer: current drawing */

        /* Controls container */
        .controls {
            display: flex;
            gap: 10px;
            margin: 10px 0;
        }

        /* UI element styles */
        button, select {
            margin: 10px;
            padding: 8px 16px;
            font-size: 16px;
            cursor: pointer;
        }
            button:hover {
                background-color: #f0f0f0;
            }
        .instruction {
            margin: 10px;
            font-size: 18px;
            color: #444;
        }
        #accuracy {
            margin: 10px;
            font-size: 16px;
            color: #666;
        }
        #letterSelect {
            margin: 10px;
            padding: 5px;
            font-size: 16px;
        }
        /* Top controls */
        .top-controls {
            width: 300px;
            display: flex;
            justify-content: center;
            margin-bottom: 10px;
        }
        /* Previous styles remain the same */
        /* Add arrow animation */
        @keyframes moveArrow {
            0% {
                transform: translateX(0) translateY(0);
            }

            50% {
                transform: translateX(10px) translateY(10px);
            }

            100% {
                transform: translateX(0) translateY(0);
            }
        }

        .arrow {
            position: absolute;
            pointer-events: none;
            animation: moveArrow 1.5s infinite;
        }
    </style>
</head>
<body>
    <h1>Letter Drawing Practice</h1>
    <div class="top-controls">
        <select id="letterSelect">
            <option value="A">Letter A</option>
            <option value="B">Letter B</option>
        </select>
    </div>
    <div class="instruction">Follow the highlighted stroke</div>
    <div id="canvas-container">
        <canvas id="ruleCanvas" width="300" height="300"></canvas>
        <canvas id="completedCanvas" width="300" height="300"></canvas>
        <canvas id="letterCanvas" width="300" height="300"></canvas>
        <canvas id="guideCanvas" width="300" height="300"></canvas>
        <canvas id="drawCanvas" width="300" height="300"></canvas>
    </div>
    <div class="controls">
        <button id="resetBtn">Reset</button>
        <button id="autoDrawBtn">Auto Draw</button>
        <button id="toggleRule">Ruled Paper?</button>
    </div>
    <div id="accuracy"></div>

    <script>
        /**
         * Letter Drawing Practice App
         *
         * This application helps users practice drawing letters by following stroke guides.
         * It uses multiple canvas layers for drawing, guides, and completed strokes.
         * Features include stroke validation, accuracy measurement, and support for both
         * straight and curved strokes.

         TODO - update to handle error when fully drawn
         */

        /**
         * Letter definitions with stroke data. Each letter consists of multiple strokes
         * Stroke types: line curve compound
         * Points: Array of coordinates defining the stroke
         */
        let letters = {
            'AA': {
                random: 'blads',
                strokes: [
                    { type: 'line', points: [{ x: 150 / 300, y: 60 / 300 }, { x: 80 / 300, y: 210 / 300 }] },
                ],
                fontStrokes: [
                    {
                        type: 'compound', subStrokes: [
                            {
                                type: 'line', points: [{ x: 150 / 300, y: 60 / 300 }, { x: 94 / 300, y: 180 / 300 }]
                            },
                            { type: 'line', points: [{ x: 94 / 300, y: 180 / 300 }, { x: 70 / 300, y: 230 / 300 }], lWidth: 80 / 300, lineCap: 'butt' }, // size cap butt square
                        ]
                    },
                ]
            },
            'f': {
                strokes: [
                    {
                        type: 'compound', subStrokes: [
                            {
                                type: 'curve', cA: '#FFA500', cS: '', points: [{ x: 200 / 300, y: 50 / 300 }, { x: 160 / 300, y: 70 / 300 }, { x: 95 / 300, y: 55 / 300 }, { x: 150 / 300, y: 90 / 300 }]
                            },
                            { type: 'line', points: [{ x: 150 / 300, y: 90 / 300 }, { x: 150 / 300, y: 220 / 300 }] },
                        ]
                    },
                    {
                        type: 'line', points: [{ x: 110 / 300, y: 100 / 300 }, { x: 190 / 300, y: 100 / 300 }],// lWidth: 40/300
                    }
                ]
                //strokes: [
                //    {
                //        type: 'compound', subStrokes: [
                //            {
                //                type: 'curve', cA: '#FFA500', cS: '', points: [{ x: 1 / 2, y: 11 / 30 }, { x: 16 / 30, y: 70 / 300 }, { x: 95 / 300, y: 55 / 300 }, { x: 9 / 30, y: 11 / 30 }]
                //            },
                //            { type: 'line', points: [{ x: 9 / 30, y: 11 / 30 }, { x: 9 / 30, y: 22 / 30 }] },
                //        ]
                //    },
                //    {
                //        type: 'line', points: [{ x: 1 / 3, y: 1 / 2 }, { x: 1 / 2, y: 1 / 2 }]
                //    }
                //]
            },
            'A': {
                strokes: [
                    {
                        type: 'line',
                        points: [{ x: 1 / 3, y: 5 / 6 }, { x: 1 / 2, y: 1 / 6 }]
                    },
                    {
                        type: 'line',
                        points: [{ x: 1 / 2, y: 1 / 6 }, { x: 2 / 3, y: 5 / 6 }]
                    },
                    {
                        type: 'line',
                        points: [{ x: 5 / 12, y: 1 / 2 }, { x: 7 / 12, y: 1 / 2 }]
                    }
                ]
            },
            'B': {
                strokes: [
                    {
                        type: 'line',
                        points: [{ x: 1 / 3, y: 1 / 6 }, { x: 1 / 3, y: 5 / 6 }]
                    },
                    {
                        type: 'curve',
                        points: [{ x: 1 / 3, y: 1 / 6 }, { x: 2 / 3, y: 1 / 6 }, { x: 2 / 3, y: 5 / 12 }, { x: 1 / 3, y: 5 / 12 }]
                    },
                    {
                        type: 'curve',
                        points: [{ x: 1 / 3, y: 5 / 12 }, { x: 2 / 3, y: 5 / 12 }, { x: 2 / 3, y: 5 / 6 }, { x: 1 / 3, y: 5 / 6 }]
                    }
                ]
            },
            'C': {
                strokes: [
                    {
                        type: 'curve',
                        points: [{ x: 2 / 3, y: 1 / 6 }, { x: 1 / 6, y: 1 / 3 }, { x: 1 / 6, y: 2 / 3 }, { x: 2 / 3, y: 5 / 6 }]
                    }
                ]
            },
            'D': {
                strokes: [
                    { type: 'line', points: [{ x: 1 / 3, y: 1 / 6 }, { x: 1 / 3, y: 5 / 6 }] },
                    { type: 'curve', points: [{ x: 1 / 3, y: 1 / 6 }, { x: 2 / 3, y: 1 / 6 }, { x: 2 / 3, y: 5 / 6 }, { x: 1 / 3, y: 5 / 6 }] }
                ]
            },
            'E': {
                strokes: [
                    { type: 'line', points: [{ x: 2 / 3, y: 1 / 6 }, { x: 1 / 3, y: 1 / 6 }] },
                    { type: 'line', points: [{ x: 1 / 3, y: 1 / 6 }, { x: 1 / 3, y: 5 / 6 }] },
                    { type: 'line', points: [{ x: 1 / 3, y: 5 / 6 }, { x: 2 / 3, y: 5 / 6 }] },
                    { type: 'line', points: [{ x: 1 / 3, y: 1 / 2 }, { x: 1 / 2, y: 1 / 2 }] }
                ]
            },
            'F': {
                strokes: [
                    { type: 'line', points: [{ x: 1 / 3, y: 1 / 6 }, { x: 1 / 3, y: 5 / 6 }] },
                    { type: 'line', points: [{ x: 1 / 3, y: 1 / 6 }, { x: 2 / 3, y: 1 / 6 }] },
                    { type: 'line', points: [{ x: 1 / 3, y: 1 / 2 }, { x: 1 / 2, y: 1 / 2 }] }
                ]
            },
            'G': {
                strokes: [
                    { type: 'curve', points: [{ x: 2 / 3, y: 5 / 12 }, { x: 1 / 3, y: 5 / 12 }, { x: 1 / 3, y: 5 / 6 }, { x: 2 / 3, y: 5 / 6 }] },
                    { type: 'line', points: [{ x: 2 / 3, y: 5 / 6 }, { x: 2 / 3, y: 2 / 3 }] }
                ]
            },
            'H': {
                strokes: [
                    { type: 'line', points: [{ x: 1 / 3, y: 1 / 6 }, { x: 1 / 3, y: 5 / 6 }] },
                    { type: 'line', points: [{ x: 2 / 3, y: 1 / 6 }, { x: 2 / 3, y: 5 / 6 }] },
                    { type: 'line', points: [{ x: 1 / 3, y: 1 / 2 }, { x: 2 / 3, y: 1 / 2 }] }
                ]
            },
            'I': {
                strokes: [
                    { type: 'line', points: [{ x: 1 / 2, y: 1 / 6 }, { x: 1 / 2, y: 5 / 6 }] },
                ]
            },
            'J': {
                strokes: [
                    { type: 'line', points: [{ x: 2 / 3, y: 1 / 6 }, { x: 2 / 3, y: 5 / 6 }] },
                    { type: 'curve', points: [{ x: 2 / 3, y: 5 / 6 }, { x: 1 / 2, y: 5 / 6 }, { x: 1 / 2, y: 2 / 3 }, { x: 2 / 3, y: 2 / 3 }] }
                ]
            },
            'K': {
                strokes: [
                    { type: 'line', points: [{ x: 1 / 3, y: 1 / 6 }, { x: 1 / 3, y: 5 / 6 }] },
                    { type: 'line', points: [{ x: 1 / 3, y: 1 / 2 }, { x: 2 / 3, y: 1 / 6 }] },
                    { type: 'line', points: [{ x: 1 / 3, y: 1 / 2 }, { x: 2 / 3, y: 5 / 6 }] }
                ]
            },
            'L': {
                strokes: [
                    { type: 'line', points: [{ x: 1 / 3, y: 1 / 6 }, { x: 1 / 3, y: 5 / 6 }] },
                    { type: 'line', points: [{ x: 1 / 3, y: 5 / 6 }, { x: 2 / 3, y: 5 / 6 }] }
                ]
            },
            'M': {
                strokes: [
                    { type: 'line', points: [{ x: 1 / 3, y: 5 / 6 }, { x: 1 / 3, y: 1 / 6 }] },
                    { type: 'line', points: [{ x: 1 / 3, y: 1 / 6 }, { x: 1 / 2, y: 1 / 2 }] },
                    { type: 'line', points: [{ x: 1 / 2, y: 1 / 2 }, { x: 2 / 3, y: 1 / 6 }] },
                    { type: 'line', points: [{ x: 2 / 3, y: 1 / 6 }, { x: 2 / 3, y: 5 / 6 }] }
                ]
            },
            'N': {
                strokes: [
                    { type: 'line', points: [{ x: 1 / 3, y: 5 / 6 }, { x: 1 / 3, y: 1 / 6 }] },
                    { type: 'line', points: [{ x: 1 / 3, y: 1 / 6 }, { x: 2 / 3, y: 5 / 6 }] },
                    { type: 'line', points: [{ x: 2 / 3, y: 5 / 6 }, { x: 2 / 3, y: 1 / 6 }] }
                ]
            },
            'O': {
                strokes: [
                    { type: 'curve', points: [{ x: 2 / 3, y: 1 / 6 }, { x: 1 / 3, y: 1 / 6 }, { x: 1 / 3, y: 5 / 6 }, { x: 2 / 3, y: 5 / 6 }] }
                ]
            },
            'P': {
                strokes: [
                    { type: 'line', points: [{ x: 1 / 3, y: 5 / 6 }, { x: 1 / 3, y: 1 / 6 }] },
                    { type: 'curve', points: [{ x: 1 / 3, y: 1 / 6 }, { x: 2 / 3, y: 1 / 6 }, { x: 2 / 3, y: 1 / 2 }, { x: 1 / 3, y: 1 / 2 }] }
                ]
            },
            'Q': {
                strokes: [
                    { type: 'curve', points: [{ x: 2 / 3, y: 1 / 6 }, { x: 1 / 3, y: 1 / 6 }, { x: 1 / 3, y: 5 / 6 }, { x: 2 / 3, y: 5 / 6 }] },
                    { type: 'line', points: [{ x: 2 / 3, y: 5 / 6 }, { x: 5 / 6, y: 4 / 6 }] }
                ]
            },
            'R': {
                strokes: [
                    { type: 'line', points: [{ x: 1 / 3, y: 5 / 6 }, { x: 1 / 3, y: 1 / 6 }] },
                    { type: 'curve', points: [{ x: 1 / 3, y: 1 / 6 }, { x: 2 / 3, y: 1 / 6 }, { x: 2 / 3, y: 1 / 2 }, { x: 1 / 3, y: 1 / 2 }] },
                    { type: 'line', points: [{ x: 1 / 3, y: 1 / 2 }, { x: 2 / 3, y: 5 / 6 }] }
                ]
            },
            'S': { // need to fix
                strokes: [
                    { type: 'curve', points: [{ x: 2 / 3, y: 1 / 6 }, { x: 1 / 3, y: 1 / 6 }, { x: 1 / 3, y: 1 / 2 }, { x: 2 / 3, y: 1 / 2 }] },
                    { type: 'curve', points: [{ x: 2 / 3, y: 1 / 2 }, { x: 2 / 3, y: 5 / 6 }, { x: 1 / 3, y: 5 / 6 }, { x: 1 / 3, y: 5 / 6 }] }
                ]
            },
            'T': {
                strokes: [
                    { type: 'line', points: [{ x: 1 / 2, y: 1 / 6 }, { x: 1 / 2, y: 5 / 6 }] },
                    { type: 'line', points: [{ x: 1 / 3, y: 1 / 6 }, { x: 2 / 3, y: 1 / 6 }] }
                ]
            },
            'U': { // need to fix. though looks good for hebrew eyin
                strokes: [
                    { type: 'line', points: [{ x: 1 / 3, y: 1 / 6 }, { x: 1 / 3, y: 5 / 6 }] },
                    { type: 'curve', points: [{ x: 1 / 3, y: 5 / 6 }, { x: 1 / 2, y: 5 / 6 }, { x: 2 / 3, y: 5 / 6 }, { x: 2 / 3, y: 1 / 6 }] }
                ]
            },
            'V': {
                strokes: [
                    { type: 'line', points: [{ x: 1 / 3, y: 1 / 6 }, { x: 1 / 2, y: 5 / 6 }] },
                    { type: 'line', points: [{ x: 1 / 2, y: 5 / 6 }, { x: 2 / 3, y: 1 / 6 }] }
                ]
            },
            'W': {
                strokes: [
                    { type: 'line', points: [{ x: 1 / 4, y: 1 / 6 }, { x: 2 / 4, y: 5 / 6 }] },
                    { type: 'line', points: [{ x: 2 / 4, y: 5 / 6 }, { x: 3 / 4, y: 1 / 6 }] },
                    { type: 'line', points: [{ x: 3 / 4, y: 1 / 6 }, { x: 1, y: 5 / 6 }] }
                ]
            },
            'X': {
                strokes: [
                    { type: 'line', points: [{ x: 1 / 3, y: 1 / 6 }, { x: 2 / 3, y: 5 / 6 }] },
                    { type: 'line', points: [{ x: 2 / 3, y: 1 / 6 }, { x: 1 / 3, y: 5 / 6 }] }
                ]
            },
            'Y': {
                strokes: [
                    { type: 'line', points: [{ x: 1 / 3, y: 1 / 6 }, { x: 1 / 2, y: 1 / 2 }] },
                    { type: 'line', points: [{ x: 2 / 3, y: 1 / 6 }, { x: 1 / 2, y: 1 / 2 }] },
                    { type: 'line', points: [{ x: 1 / 2, y: 1 / 2 }, { x: 1 / 2, y: 5 / 6 }] }
                ]
            },
            'Z': {
                strokes: [
                    { type: 'line', points: [{ x: 1 / 3, y: 1 / 6 }, { x: 2 / 3, y: 1 / 6 }] },
                    { type: 'line', points: [{ x: 2 / 3, y: 1 / 6 }, { x: 1 / 3, y: 5 / 6 }] },
                    { type: 'line', points: [{ x: 1 / 3, y: 5 / 6 }, { x: 2 / 3, y: 5 / 6 }] }
                ]
            },
            'a': {
                strokes: [
                    { type: 'curve', points: [{ x: 2 / 3, y: 1 / 2 }, { x: 1 / 3, y: 1 / 2 }, { x: 1 / 3, y: 5 / 6 }, { x: 2 / 3, y: 5 / 6 }] },
                    { type: 'line', points: [{ x: 2 / 3, y: 5 / 6 }, { x: 2 / 3, y: 1 / 6 }] }
                ]
            },
            'b': {
                strokes: [
                    { type: 'line', points: [{ x: 1 / 3, y: 1 / 6 }, { x: 1 / 3, y: 5 / 6 }] },
                    { type: 'curve', points: [{ x: 1 / 3, y: 1 / 2 }, { x: 2 / 3, y: 1 / 2 }, { x: 2 / 3, y: 5 / 6 }, { x: 1 / 3, y: 5 / 6 }] }
                ]
            },
            'c': {
                strokes: [
                    { type: 'curve', points: [{ x: 2 / 3, y: 1 / 2 }, { x: 1 / 3, y: 1 / 2 }, { x: 1 / 3, y: 5 / 6 }, { x: 2 / 3, y: 5 / 6 }] }
                ]
            },
            'd': {
                strokes: [
                    { type: 'line', points: [{ x: 2 / 3, y: 1 / 6 }, { x: 2 / 3, y: 5 / 6 }] },
                    { type: 'curve', points: [{ x: 2 / 3, y: 1 / 2 }, { x: 1 / 3, y: 1 / 2 }, { x: 1 / 3, y: 5 / 6 }, { x: 2 / 3, y: 5 / 6 }] }
                ]
            },
            'e': {
                strokes: [
                    { type: 'line', points: [{ x: 1 / 3, y: 1 / 2 }, { x: 2 / 3, y: 1 / 2 }] },
                    { type: 'curve', points: [{ x: 2 / 3, y: 1 / 2 }, { x: 1 / 3, y: 1 / 6 }, { x: 1 / 3, y: 5 / 6 }, { x: 2 / 3, y: 5 / 6 }] }
                    // { type: 'curve', points: [{ x: 2 / 3, y: 1 / 2 }, { x: 2 / 3, y: 1 / 6 }, { x: 1 / 3, y: 1 / 6 }, { x: 1 / 3, y: 5 / 6 }, { x: 2 / 3, y: 5 / 6 }] } five points
                ]
            },

            'g': {
                strokes: [
                    { type: 'curve', points: [{ x: 2 / 3, y: 1 / 2 }, { x: 1 / 3, y: 1 / 2 }, { x: 1 / 3, y: 5 / 6 }, { x: 2 / 3, y: 5 / 6 }] },
                    { type: 'line', points: [{ x: 2 / 3, y: 5 / 6 }, { x: 2 / 3, y: 7 / 6 }] }
                ]
            },
            'h': {
                strokes: [
                    { type: 'line', points: [{ x: 1 / 3, y: 1 / 6 }, { x: 1 / 3, y: 5 / 6 }] },
                    { type: 'line', points: [{ x: 1 / 3, y: 1 / 2 }, { x: 2 / 3, y: 1 / 2 }] }
                ]
            },
            'i': {
                strokes: [
                    { type: 'line', points: [{ x: 1 / 2, y: 1 / 6 }, { x: 1 / 2, y: 5 / 6 }] },
                    { type: 'line', points: [{ x: 1 / 2, y: 1 / 12 }, { x: 1 / 2, y: 2 / 12 }] }
                ]
            },
            'j': {
                strokes: [
                    { type: 'line', points: [{ x: 1 / 2, y: 1 / 6 }, { x: 1 / 2, y: 5 / 6 }] },
                    { type: 'curve', points: [{ x: 1 / 2, y: 5 / 6 }, { x: 2 / 3, y: 5 / 6 }, { x: 2 / 3, y: 7 / 6 }, { x: 1 / 2, y: 7 / 6 }] },
                    { type: 'line', points: [{ x: 1 / 2, y: 1 / 12 }, { x: 1 / 2, y: 2 / 12 }] }
                ]
            },
            'k': {
                strokes: [
                    { type: 'line', points: [{ x: 1 / 3, y: 1 / 6 }, { x: 1 / 3, y: 5 / 6 }] },
                    { type: 'line', points: [{ x: 1 / 3, y: 1 / 2 }, { x: 2 / 3, y: 1 / 4 }] },
                    { type: 'line', points: [{ x: 1 / 3, y: 1 / 2 }, { x: 2 / 3, y: 3 / 4 }] }
                ]
            },
            'l': {
                strokes: [
                    { type: 'line', points: [{ x: 1 / 2, y: 1 / 6 }, { x: 1 / 2, y: 5 / 6 }] }
                ]
            },
            'm': {
                strokes: [
                    { type: 'line', points: [{ x: 1 / 4, y: 1 / 2 }, { x: 1 / 4, y: 5 / 6 }] },
                    { type: 'line', points: [{ x: 1 / 4, y: 1 / 2 }, { x: 2 / 4, y: 1 / 2 }] },
                    { type: 'line', points: [{ x: 2 / 4, y: 1 / 2 }, { x: 2 / 4, y: 5 / 6 }] },
                    { type: 'line', points: [{ x: 2 / 4, y: 1 / 2 }, { x: 3 / 4, y: 1 / 2 }] },
                    { type: 'line', points: [{ x: 3 / 4, y: 1 / 2 }, { x: 3 / 4, y: 5 / 6 }] }
                ]
            },
            'n': {
                strokes: [
                    { type: 'line', points: [{ x: 1 / 3, y: 1 / 2 }, { x: 1 / 3, y: 5 / 6 }] },
                    { type: 'line', points: [{ x: 1 / 3, y: 1 / 2 }, { x: 2 / 3, y: 1 / 2 }] },
                    { type: 'line', points: [{ x: 2 / 3, y: 1 / 2 }, { x: 2 / 3, y: 5 / 6 }] }
                ]
            },
            'o': {
                strokes: [
                    { type: 'curve', points: [{ x: 2 / 3, y: 1 / 2 }, { x: 1 / 3, y: 1 / 2 }, { x: 1 / 3, y: 5 / 6 }, { x: 2 / 3, y: 5 / 6 }] }
                ]
            },
            'p': {
                strokes: [
                    { type: 'line', points: [{ x: 1 / 3, y: 1 / 2 }, { x: 1 / 3, y: 7 / 6 }] },
                    { type: 'curve', points: [{ x: 1 / 3, y: 1 / 2 }, { x: 2 / 3, y: 1 / 2 }, { x: 2 / 3, y: 5 / 6 }, { x: 1 / 3, y: 5 / 6 }] }
                ]
            },
            'q': {
                strokes: [
                    { type: 'line', points: [{ x: 2 / 3, y: 1 / 2 }, { x: 2 / 3, y: 7 / 6 }] },
                    { type: 'curve', points: [{ x: 2 / 3, y: 1 / 2 }, { x: 1 / 3, y: 1 / 2 }, { x: 1 / 3, y: 5 / 6 }, { x: 2 / 3, y: 5 / 6 }] }
                ]
            },
            'r': {
                strokes: [
                    { type: 'line', points: [{ x: 1 / 3, y: 1 / 2 }, { x: 1 / 3, y: 5 / 6 }] },
                    { type: 'line', points: [{ x: 1 / 3, y: 1 / 2 }, { x: 2 / 3, y: 1 / 2 }] }
                ]
            },
            's': {
                strokes: [
                    { type: 'curve', points: [{ x: 2 / 3, y: 1 / 2 }, { x: 1 / 3, y: 1 / 2 }, { x: 1 / 3, y: 5 / 6 }, { x: 2 / 3, y: 5 / 6 }] },
                    { type: 'curve', points: [{ x: 2 / 3, y: 5 / 6 }, { x: 2 / 3, y: 1 / 6 }, { x: 1 / 3, y: 1 / 6 }, { x: 1 / 3, y: 1 / 2 }] }
                ]
            },
            't': {
                strokes: [
                    { type: 'line', points: [{ x: 1 / 2, y: 1 / 6 }, { x: 1 / 2, y: 5 / 6 }] },
                    { type: 'line', points: [{ x: 1 / 3, y: 1 / 3 }, { x: 2 / 3, y: 1 / 3 }] }
                ]
            },
            'u': {
                strokes: [
                    { type: 'line', points: [{ x: 1 / 3, y: 1 / 2 }, { x: 1 / 3, y: 5 / 6 }] },
                    { type: 'curve', points: [{ x: 1 / 3, y: 5 / 6 }, { x: 1 / 2, y: 5 / 6 }, { x: 2 / 3, y: 5 / 6 }, { x: 2 / 3, y: 1 / 2 }] }
                ]
            },
            'v': {
                strokes: [
                    { type: 'line', points: [{ x: 1 / 3, y: 1 / 2 }, { x: 1 / 2, y: 5 / 6 }] },
                    { type: 'line', points: [{ x: 1 / 2, y: 5 / 6 }, { x: 2 / 3, y: 1 / 2 }] }
                ]
            },
            'w': {
                strokes: [
                    { type: 'line', points: [{ x: 1 / 4, y: 1 / 2 }, { x: 2 / 4, y: 5 / 6 }] },
                    { type: 'line', points: [{ x: 2 / 4, y: 5 / 6 }, { x: 3 / 4, y: 1 / 2 }] },
                    { type: 'line', points: [{ x: 3 / 4, y: 1 / 2 }, { x: 1, y: 5 / 6 }] }
                ]
            },
            'x': {
                strokes: [
                    { type: 'line', points: [{ x: 1 / 3, y: 1 / 2 }, { x: 2 / 3, y: 5 / 6 }] },
                    { type: 'line', points: [{ x: 2 / 3, y: 1 / 2 }, { x: 1 / 3, y: 5 / 6 }] }
                ]
            },
            'y': {
                strokes: [
                    { type: 'line', points: [{ x: 1 / 3, y: 1 / 2 }, { x: 1 / 2, y: 5 / 6 }] },
                    { type: 'line', points: [{ x: 1 / 2, y: 5 / 6 }, { x: 2 / 3, y: 1 / 2 }] },
                    { type: 'line', points: [{ x: 2 / 3, y: 1 / 2 }, { x: 2 / 3, y: 7 / 6 }] }
                ]
            },
            'z': {
                strokes: [
                    { type: 'line', points: [{ x: 1 / 3, y: 1 / 2 }, { x: 2 / 3, y: 1 / 2 }] },
                    { type: 'line', points: [{ x: 2 / 3, y: 1 / 2 }, { x: 1 / 3, y: 5 / 6 }] },
                    { type: 'line', points: [{ x: 1 / 3, y: 5 / 6 }, { x: 2 / 3, y: 5 / 6 }] }
                ]
            },
        };

        const animDur = 1000;

        let canvasDim = 300; // square

        // Canvas setup
        const ruleCanvas = document.getElementById('ruleCanvas');
        const ruleCtx = ruleCanvas.getContext('2d');      
        const completedCanvas = document.getElementById('completedCanvas');
        const completedCtx = completedCanvas.getContext('2d', { willReadFrequently: true });
        const guideCanvas = document.getElementById('guideCanvas');
        const guideCtx = guideCanvas.getContext('2d');
        const letterCanvas = document.getElementById('letterCanvas');
        const letterCtx = letterCanvas.getContext('2d', { willReadFrequently: true });
        const drawCanvas = document.getElementById('drawCanvas');
        const drawCtx = drawCanvas.getContext('2d');
        
        const accuracyDisplay = document.getElementById('accuracy');
        let rulePaper = true;

        // Draw styles
        class Style {
            constructor(style) {
                this.normed = [];
                Object.assign(this, style);
                this.normed.push('lWidth', 'headLength', 'headWidth');
                return new Proxy(this, {
                    get(target, prop) {
                        if (prop in target) {
                            // Custom behavior for accessing properties console.log(`Accessing property '${prop}' with value '${target[prop]}'`);
                            if (target.normed.includes(prop)) {
                                return target[prop] * canvasDim;
                            } else {
                                // throw new Error(`Property '${prop}' is not normalized`);
                                return target[prop];
                            }
                        } else {
                            throw new Error(`Property '${prop}' does not exist`);
                        }
                    }
                })
            }
        }

        const ruleStyle = new Style({ color: '#FFA500', lWidth: .01, headLength: 1 / 15, headWidth: 15 / 300, normed: [] }); // guide arrow color - orange. normalized
        const arwStyle = new Style({ color: '#FFA500', lWidth: .01, headLength: 1 / 15, headWidth: 15 / 300 }); // guide arrow color - orange. normalized
        const guideStyle = new Style({ color: '#90EE90', lWidth: 20 / 300, lineCap: 'round' }); // guide stroke color gray dddddd. normalized
        const hlStyle = new Style({ color: '#ffeb3b', lWidth: 20 / 300, lineCap: 'round' }); // // highlight guide stroke color - yellow. normalized
        const completeStyle = new Style({ color: '#ff1111', lWidth: 20 / 300, lineCap: 'round' }); // // highlight guide stroke color - yellow. normalized
        // ({ color: ctx.strokeStyle, lWidth: ctx.lineWidth, lineCap: ctx.lineCap } = guideStyle); // ctx = guideCtx need to de normalize

        // Stroke
        class Stroke {
            constructor(stroke) {
                this.normed = [];
                Object.assign(this, stroke); // type:''  points {x:,y:} substroke:[Stroke,] others
                this.normed.push('lWidth', 'x', 'y', 'points');
                // handle compounds
                if (this.type == 'compound') {
                    this.subStrokes = this.subStrokes.map((s) => new Stroke(s))
                }
                this.pLen = this.pLenFind();
                this.check();
                return new Proxy(this, {
                    get(target, prop) {
                        if (prop in target) {
                            // Denorm any normed properties
                            if (target.normed.includes(prop)) {
                                if (prop === 'points') {
                                    return target[prop].map((p) => {
                                        let res = {};
                                        Object.assign(res, p);
                                        res.x *= canvasDim;
                                        res.y *= canvasDim;
                                        return res
                                    })
                                }
                                return target[prop] * canvasDim;
                            } else {
                                return target[prop];
                            }
                        } else {
                            if (typeof prop ==='symbol') { console.log(prop); }
                            // throw new Error(`Property: ${prop.toSring()} - does not exist`);
                        }
                    },
                    has(target, prop) {
                        return prop in target; // This allows the "in" operator to work without throwing an error }
                    }
                })
            }

            /**
             * Calculates avg error between user's drawn path and ideal stroke
             * Returns a % score (0-100)
             */
            calculateAccuracy(userPath) {
                if (userPath.length < 2) return 0;

                const numSamples = 50;
                let totalError = 0;

                const maxAllowedError = 100; // pixels
                // Sample points along both paths
                for (let i = 0; i <= numSamples; i++) {
                    const t = i / numSamples;

                    const idealPoint = this.getPt(t); // 
                    const userPoint = interpolatePathPoint(userPath, t);
                    //console.log(idealPoint);
                    //console.log(userPoint);
                    let error = Math.hypot(userPoint.x - idealPoint.x, userPoint.y - idealPoint.y);

                    // not sure why but error is sometimes Nan
                    if (isNaN(error)) {
                        error = maxAllowedError * 2;
                        //console.log(`Nan error. upx ${userPoint.x} ipx ${idealPoint.x} upy  ${userPoint.y} ipy ${idealPoint.y}`);
                    }
                    totalError += error;
                }
                //console.log(`val totalError ${totalError}`);
                let avgError = totalError / (numSamples + 1);
                //console.log(`val avgError ${avgError}`);

                if (avgError == 0) avgError = maxAllowedError; // prevent all NaN from appearing to be perfect
                return Math.max(0, Math.min(100, 100 * (1 - avgError / maxAllowedError)));
            }

            /**
             * Animates a single stroke
             */
            async animateStroke(duration = 1000, drawOver = false) {
                return new Promise(resolve => {
                    let startTime = null;
                    let stroke = this;
                    let ctx = completedCtx;
                    if (isAutoDrawing) saveState(ctx, 'b4 stroke/sub');
                    let temp = letterCtx.getImageData(0, 0, canvasDim, canvasDim);
                    // Clear completed and guide canvases WHEN/IF to clear
                    //ctx.clearRect(0, 0, canvasDim, canvasDim);
                    guideCtx.clearRect(0, 0, canvasDim, canvasDim);
                    console.log(drawOver);

                    function animate(timestamp) {
                        //if (isAutoDrawing) restoreState(ctx, 'b4 stroke/sub');
                        if (!startTime) startTime = timestamp;
                        const progress = Math.min((timestamp - startTime) / duration, 1);

                        //// Draw the stroke in progress
                        ctx.strokeStyle = '#2196f3';
                        ctx.strokeStyle = '#00aa00';
                        ctx.lineWidth = 20;
                        ctx.lineCap = 'round';
                        //console.log(ctx);
                        //// console.log(stroke.points[0].x);
                        ctx.globalCompositeOperation = 'source-over';
                        completedCtx.beginPath();
                        completedCtx.moveTo(0, 100);
                        completedCtx.lineTo(50, 100);
                        completedCtx.stroke();
                        //// Use style 
                        // ({color:ctx.strokeStyle,}= guideStyle)
                        stroke.drawStroke(completedCtx, completeStyle, progress); // check if stroke carries changes for line width

                        //// source-atop letter source completed destination
                        completedCtx.globalCompositeOperation = 'destination-in'; // 'destination-in'; CHange back onve fix issue
                        console.log(drawOver);
                        if (drawOver) {
                            completedCtx.globalCompositeOperation = 'destination-over';
                        }; // 'destination-in'; CHange back onve fix issue


                        //completedCtx.putImageData(temp, 0, 0);
                        completedCtx.drawImage(letterCanvas, 0, 0);
                        
                        //// combine the stroke with the font letter

                        if (progress < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            if (isAutoDrawing) clearState('b4 stroke/sub');
                            ctx.globalCompositeOperation = 'source-over'; // back to default
                            resolve();
                        }
                    }

                    requestAnimationFrame(animate);
                });
            }

            async animateCompoundStroke(animDur, drawOver = false) {
                let { relLens:relLens } = this.pLen;
                for (let subi = 0; subi < this.subStrokes.length; subi++) {
                    await this.subStrokes[subi].animateStroke(animDur * relLens[subi], drawOver);
                }
            }

            pLenFind(numSegments = 100) {
                let len = 0;
                if (this.type === 'line') {
                    let [p0, p1] = this.points;
                    len = Math.hypot(p1.x - p0.x, p1.y - p0.y);
                    return len
                }
                else if (this.type === 'curve') {
                    let [p0, ...rest] = this.points;
                    let pp = p0; // prevPoint
                    for (let i = 1; i <= numSegments; i++) {
                        const t = i / numSegments;
                        const p = this.getPt(t);
                        len += Math.hypot(p.x - pp.x, p.y - pp.y);
                        pp = p;
                    }
                    return len
                }
                else if (this.type === 'compound') {
                    this.subStrokes.forEach((s) => {
                        len += s.pLenFind();
                    });
                    let rl = this.subStrokes.map((s) => s.pLenFind() / len); // []
                    return { totLen: len, relLens: rl }
                }
            }

            /**
             * Calculates a point on a stroke at given progress (0-1)
             * Handles both line and curve strokes
             */
             getPt(progress) {
                // console.log(`getPt stroke.type: ${stroke.type}`);
                 //let { totLen, relLens } = pLenFind(stroke);
                const t = progress;
                try {
                    this.type === 'line';

                } catch (err) {
                    console.log(err);
                    console.log(this);
                }
                if (this.type === 'line') {
                    const start = this.points[0];
                    const end = this.points[1];
                    return {
                        x: start.x + (end.x - start.x) * t,
                        y: start.y + (end.y - start.y) * t
                    };
                } else if (this.type === 'curve') {
                    const mt = 1 - t;
                    const [p0, p1, p2, p3] = this.points;
                    return {
                        x: mt ** 3 * p0.x + 3 * mt * mt * t * p1.x + 3 * mt * t * t * p2.x + t ** 3 * p3.x,
                        y: mt ** 3 * p0.y + 3 * mt * mt * t * p1.y + 3 * mt * t * t * p2.y + t ** 3 * p3.y
                    };
                } else if (this.type === 'compound') {
                    let { relLens } = this.pLenFind();
                    let si = relLens.findIndex(element => element > t); // subStroke index
                    if (si == -1) si = relLens.length - 1;
                    let subS = si == 0 ? 0 : relLens[si - 1];
                    let subE = si == relLens.length - 1 ? 1 - relLens[si] : relLens[si + 1] - relLens[si];
                    let partprog = (t - subS) / (subE - subS);
                    if (partprog > 1) partprog = 1;
                    return this.subStrokes[si].getPt(partprog);
                }
             }

            /**
             * Draws a stroke on the specified context
             * checks for change of stroke parameters
             */
            drawStroke(ctx, style, progress = 1) {
                // set style for the stroke
                ctx.strokeStyle = style.color || '#2196f3';
                ctx.lineWidth = style.lWidth || 20;
                ctx.lineCap = style.lineCap || 'round';

                // check if style change to thickness in stroke
                if (this.lineCap) ctx.lineCap = this.lineCap;
                if (this.lWidth) ctx.lineWidth = this.lWidth;

                if (this.type === 'compound') { // shouldn't happen with animate
                    this.subStrokes.forEach(sub => {
                        sub.drawStroke(ctx, style, progress);
                    });
                    return;
                }

                ctx.beginPath();
                let start = this.points[0]; // could be a compound then this is an issue
                ctx.moveTo(start.x, start.y);
                if (this.type === 'line') {
                    const point = this.getPt(progress);
                    ctx.lineTo(point.x, point.y);
                }
                else if (this.type === 'curve') {
                    let [start, cp1, cp2, end] = this.points;
                    if (progress === 1) {
                        ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, end.x, end.y);
                    } else {
                        const cps = Stroke.partialBezier(progress, start.x, start.y, cp1.x, cp1.y, cp2.x, cp2.y, end.x, end.y);
                        ctx.bezierCurveTo(cps.newCx1, cps.newCy1, cps.newCx2, cps.newCy2, cps.newX2, cps.newY2);
                    }
                }

                // Ensure we're using source-over composition
                ctx.globalCompositeOperation = 'source-over';
                ctx.stroke();
            }

            /**
             * Draws direction indicators for the current stroke
             */
            drawDirections() {
                const ctx = guideCtx;
                if (this.type === 'line') {
                    this.drawArrow(ctx, this.points[0], this.points[1]);
                } else if (this.type === 'curve' || this.type === 'compound') {
                    this.drawArrow(ctx);
                }
            }

            /**
             * Draws a guide arrow
             * For curves, draw one arrow line with multiple heads along the path. For lines, draw a single arrow
             * @param {CanvasRenderingContext2D} ctx - The canvas context
             * @param {Object} start - Start point {x, y}
             * @param {Object} end - End poi        nt {x, y} 
             * @param {String} type - the type of the stroke could also be just_heads following a curve
             */
            drawArrow(ctx, start = 0, end = 0, just_head = false) { // may or may not still need to pass type for curve/compune /just_heads start and en are only needed for curve simply call Stroke.drawArrow(ctx)
                // Set styling
                let hl, hw;
                ({ color: ctx.strokeStyle, color: ctx.fillStyle, lWidth: ctx.lineWidth, headLength: hl, headWidth: hw } = arwStyle);
                const type = this.type;
                if (type === 'curve' && !just_head) {
                    // Draw arrow line
                    ctx.beginPath();
                    let [start, cp1, cp2, end] = this.points;
                    ctx.moveTo(start.x, start.y);
                    ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, end.x, end.y);
                    ctx.stroke();
                    // Draw arrow heads (schedule)
                    // set locations for arrow heads. midpoints of loci
                    let loci = [.19, .20, .49, .50, .79, .80];
                    const points = loci.map((l) => this.getPt(l));
                    for (let i = 0; i < points.length; i += 2) {
                        this.drawArrow(ctx, points[i], points[i + 1], true);
                    }
                    return
                }
                else if (type === 'line' || just_head) {

                    if (type === 'line') { // Draw arrow line
                        start = this.points[0];
                        end = this.points[1];
                        ctx.beginPath();
                        ctx.moveTo(start.x, start.y);
                        ctx.lineTo(end.x, end.y);
                        ctx.stroke();
                    }
                    // Draw arrow heads (here) around midpoint
                    const halfHead = hl / 2;
                    const arrAng = Math.atan(hw / (2 * hl));
                    const hyp = (hw / 2) / Math.sin(arrAng);
                    // Calculate the angle of the line
                    const angle = Math.atan2(end.y - start.y, end.x - start.x);
                    // Calculate the midpoint of the line
                    const midX = (start.x + end.x) / 2;
                    const midY = (start.y + end.y) / 2;

                    // find arrow points
                    const headPt0 = {
                        x: midX + halfHead * Math.cos(angle),
                        y: midY + halfHead * Math.sin(angle)
                    }
                    const headPt1 = {
                        x: headPt0.x - hyp * Math.cos(angle - arrAng),
                        y: headPt0.y - hyp * Math.sin(angle - arrAng)
                    }
                   const  headPt2 = {
                        x: headPt0.x - hyp * Math.cos(angle + arrAng),
                        y: headPt0.y - hyp * Math.sin(angle + arrAng)
                    }
                    ctx.beginPath();
                    ctx.moveTo(headPt0.x, headPt0.y);
                    ctx.lineTo(headPt1.x, headPt1.y);
                    ctx.lineTo(headPt2.x, headPt2.y);
                    ctx.closePath();
                    ctx.fill();
                }
                else if (type === 'compound') {
                    this.subStrokes.forEach((sub) => sub.drawArrow(ctx));
                }

            }

            check() {
                function checkPt(p) {
                    // only two points and both are between 0-1
                    if (!('x' in p) || !('y' in p)) {
                        throw new Error("Point must have 'x' and 'y' fields.");
                    } if (p.x <= 0 || p.x >= canvasDim || p.y <= 0 || p.y >= canvasDim) {
                        throw new Error("'x' and 'y' values must be between 0 and 1 inclusive.");
                    }
                }
                if (this.type === "line") {
                    if (this.points.length != 2) {
                        throw new Error("A line should have two points");
                    }
                    this.points.forEach((p) => checkPt(p));
                }
                else if (this.type === "curve") {
                    if (this.points.length != 4) {
                        throw new Error("A curve should have four points");
                    }
                    this.points.forEach((p) => checkPt(p));
                }
                else if (this.type === "compound") {
                    this.subStrokes.forEach((s) => s.check());
                }
                else {
                    throw new Error("A curve should have four points");
                }
            }

            /**
             * Calculate the extension line for a stroke. Prints use for making strokes
             * @param {number} extensionLength - Length to extend the curve
             * @param {'start'|'end'} position - Whether to extend from start or end of curve
             * @returns {{start: {x: number, y: number}, end: {x: number, y: number}}} Extension line points
             */
            calcExtenLine(extensionLength, position = 'end') {

                if (this.type === 'compound') {
                    const subInd = positon === 'end' ? this.subStrokes.length : 0;
                    const subStroke = this.subStrokes[subInd];
                    console.log(`extending subStroke ${subInd}`);
                    return subStroke.calcExtenLine(extensionLength, position);
                } else if (this.type === 'curve') {
                    const crvPts = this.points;
                    // Get the tangent at the extension point
                    const t = position === 'end' ? 1 : 0;
                    const tangent = this.getBezierTangent(t);

                    // Get the point to extend from
                    const extensionStart = position === 'end'
                        ? crvPts[crvPts.length - 1]
                        : crvPts[0];

                    // Calculate the extension end point
                    const extensionEnd = {
                        x: extensionStart.x + (tangent.x * extensionLength),
                        y: extensionStart.y + (tangent.y * extensionLength)
                    };
                    console.log(`extension line: {type='line' points=[{x:${extensionStart.x},
                        y:${extensionStart.y}},{x:${extensionEnd.x},y:${extensionEnd.y}}]`);
                    return {
                        start: extensionStart,
                        end: extensionEnd
                    };
                } else if (this.type === 'line') {
                    const [p1, p0] = this.points;
                    if (position === 'end') [p0, p1] = [p1, p0];
                    const len = this.pLen;
                    let x = p1.x - p0.x;
                    let y = p1.y - p0.y;
                    const tangent = { x: x / len, y: y / len } //TODO finish
                    const extensionStart = p1;
                    const extensionEnd = {
                        x: extensionStart.x + (tangent.x * extensionLength),
                        y: extensionStart.y + (tangent.y * extensionLength)
                    };
                    console.log(`extension line: {type='line' points=[{x:${extensionStart.x},
                        y:${extensionStart.y}},{x:${extensionEnd.x},y:${extensionEnd.y}}]`);
                    return {
                        start: extensionStart,
                        end: extensionEnd
                    };
                }

            }

            /**
             * Calculates the control points and end point for a Bézier curve which is in progress.
             *
             * @param {number} t - Progress of curve from 0 to 1.
             * @param {number} x1 - x-coord of start pt.
             * @param {number} y1 - y-coord of start pt.
             * @param {number} cx1 - x-coord of first control pt.
             * @param {number} cy1 - y-coord of first control pt.
             * @param {number} cx2 - x-coord of second control pt.
             * @param {number} cy2 - y-coord of second control pt.
             * @param {number} x2 - x-coord of end pt.
             * @param {number} y2 - y-coord of end pt.
             * @returns {Object} The updated control pts and end pt.
             * @returns {number} returns.newCx1 - x-coord of updated control pt 1.
             * @returns {number} returns.newCy1 - y-coord of updated control pt 1.
             * @returns {number} returns.newCx2 - x-coord of updated second control pt.
             * @returns {number} returns.newCy2 - y-coord of updated second control pt.
             * @returns {number} returns.newX2 - x-coord of updated end pt.
             * @returns {number} returns.newY2 - y-coord of updated end pt.
             */
            static partialBezier(t, x1, y1, cx1, cy1, cx2, cy2, x2, y2) {

                        // Function to interpolate between two points
                        function lerp(a, b, t) {
                            return a + (b - a) * t;
                        }

                        // Calculate intermediate points
                        const x12 = lerp(x1, cx1, t), y12 = lerp(y1, cy1, t);
                        const x23 = lerp(cx1, cx2, t), y23 = lerp(cy1, cy2, t);
                        const x34 = lerp(cx2, x2, t), y34 = lerp(cy2, y2, t);

                        const x123 = lerp(x12, x23, t), y123 = lerp(y12, y23, t);
                        const x234 = lerp(x23, x34, t), y234 = lerp(y23, y34, t);

                        const x1234 = lerp(x123, x234, t), y1234 = lerp(y123, y234, t);
                        // Return the updated control points
                        return {
                            newCx1: x12, newCy1: y12, newCx2: x123, newCy2: y123, newX2: x1234, newY2: y1234
                        };
                   }

            /**
             * Calculate the normalized tangent vector at a point on the Bézier curve
             * @param {number} t - Parameter value (0 to 1)
             * @returns {{x: number, y: number}} Normalized tangent vector
             */
            getBezierTangent(t) {
                // Get derivative at point
                const derivative = this.getBezierDerivative(t);

                // Normalize the tangent vector
                const length = Math.sqrt(derivative.x * derivative.x + derivative.y * derivative.y);
                return {
                    x: derivative.x / length,
                    y: derivative.y / length
                };
            }

            /**
             * Calculate the derivative of a Bézier curve at parameter t

             * @param {number} t - Parameter value (0 to 1)
             * @returns {{x: number, y: number}} Derivative vector
             */
            getBezierDerivative(t) {
                const points = this.points;
                const n = points.length - 1;
                let dx = 0;
                let dy = 0;

                for (let i = 0; i < n; i++) {
                    const coefficient = n * this.binomialCoefficient(n - 1, i) * Math.pow(1 - t, n - 1 - i) * Math.pow(t, i);
                    dx += coefficient * (points[i + 1].x - points[i].x);
                    dy += coefficient * (points[i + 1].y - points[i].y);
                }

                return { x: dx, y: dy };
            }

            /**
             * Calculate binomial coefficient (n choose k)
             * @param {number} n 
             * @param {number} k 
             * @returns {number}
             */
            binomialCoefficient(n, k) {
                if (k === 0 || k === n) return 1;
                if (k > n) return 0;

                let coefficient = 1;
                for (let i = 0; i < k; i++) {
                    coefficient *= (n - i) / (i + 1);
                }
                return coefficient;
            }

            drawExtenLine(lineWidth, extensionLength, position = 'end') {
                
            }
        }

        // Letter
        class Letter {
            constructor(letter) {
                this.normed = [];
                Object.assign(this, letter);
                this.normed.push('', '', '');
                // if stroke in letter else warning
                if ('strokes' in letter) {
                    this.strokes = this.strokes.map((stroke) => {
                        const ns = new Stroke(stroke);
                        return ns
                    });
                } else {
                    console.error(`letter has no stroke data`);
                }
                // if fontStrokes in letter (may not be since it is only included if diff than strokes)
                if ('fontStrokes' in letter) { 
                    this.fontStrokes = this.fontStrokes.map((stroke) => {
                        const ns = new Stroke(stroke);
                        ns.check()
                        return ns
                    });
                }
                return new Proxy(this, {
                    get(target, prop) { // a letter
                        if (prop in target) {
                            // Custom behavior for accessing properties 
                            if (target.normed.includes(prop)) {
                                return target[prop] * canvasDim;
                            } else {
                                // throw new Error(`Property '${prop}' is not normalized`);
                                return target[prop];
                            }
                        } else {
                            if(prop != 'fontStrokes') throw new Error(`Letter '${letter.name}' has no prop ${prop}`);
                        }
                    }
                })
            }
        }

        // Letter Database - make all letter class at start or only when called
        class LetterDatabase {
            constructor(letters) {
                const makeAllAtStart = true;

                Object.assign(this, letters);

                if (makeAllAtStart) {
                    for (let [key, value] of Object.entries(this)) {
                        try {
                            this[key].name = key;
                            this[key] = new Letter(value);
                            // console.log('stroke[0], stroke[0].points, fontStrokes)');                            console.log(this[key].strokes[0]);                            console.log(this[key].strokes[0].points);                            console.log(this[key].fontStrokes);                            console.log(this[key].fontStrokes[0].subStrokes[0].points);
                        } catch (e) {
                            console.log(`error on letter: ${key}`);
                            throw e;
                        }
                    }
                }

                return new Proxy(this, {
                    get(target, prop) { // a letter
                        if (prop in target) {
                            if (makeAllAtStart) {
                                return target[prop]
                            } else {// make on demand.
                                return new Letter(target[prop]);
                            }     
                        } else {
                            throw new Error(`Letter '${prop}' not in db`);
                        }
                    }
                })
            }
        }

        function drawFontLetter(currentLetter) {
            // switch canvas 
            // let letterCtx = guideCtx; //temp
            // Clear letter canvas
            letterCtx.clearRect(0, 0, canvasDim, canvasDim);
            // drawCtx.globalCompositeOperation = 'source-over';
            // Draw letter in light gray
            letterCtx.fillStyle = '#DDDDDD';
            letterCtx.font = 'bold 250px Times New Roman';
            letterCtx.font = 'bold 250px Arial';
            letterCtx.textAlign = 'center';
            letterCtx.textBaseline = 'middle';

            letterCtx.fillText(currentLetter, canvasDim / 2, canvasDim / 2);

            // Get the letter pixels
            const imageData = letterCtx.getImageData(0, 0, canvasDim, canvasDim);
            letterPixels = imageData.data;
        }

        function drawLineRule(ctx) {
            ctx.clearRect(0, 0, canvasDim, canvasDim);
            if (!rulePaper) return
            ctx = ctx || ruleCtx;

            function drawHorizontalLine(y) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvasDim, y);
                ctx.stroke();
            }
            // Clear canvas and set white background
            ctx.fillStyle = 'white';
            ctx.globalCompositeOperation = 'destination-over';
            ctx.fillRect(0, 0, canvasDim, canvasDim);
            ctx.globalCompositeOperation = 'source-over';

            // Bottom solid black line
            ctx.setLineDash([]); // Solid line
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1 / 100 * canvasDim;
            drawHorizontalLine(215 / 300 * canvasDim);

            // Middle dashed red line
            ctx.setLineDash([5, 5]); // Dashed line
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)'; // Pale red
            drawHorizontalLine(160 / 300 * canvasDim);

            // Top dashed blue line
            ctx.strokeStyle = 'rgba(0, 0, 255, 0.3)'; // Pale blue
            drawHorizontalLine(45 / 300 * canvasDim);

            // Reset line dash for drawing
            ctx.setLineDash([]);
        }

        function denormConsts() {
            // TODO set the pixsl value based on the canvasDim
        }

        function showStroke() {

        }

        function markPoints(canvasId) {
            // top canvas is draw
            const canvas = document.getElementById(canvasId);
            const colors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'];
            const circleRadius = 10;
            let circleCount = 0;
            let colorIndex = 0;
            
            canvas.addEventListener('dblclick', (event) => {
                const ctx = guideCanvas.getContext('2d');
                const x = event.offsetX;
                const y = event.offsetY;
                const color = colors[colorIndex % colors.length];

                ctx.beginPath();
                ctx.arc(x, y, circleRadius, 0, 2 * Math.PI);
                ctx.fillStyle = color;
                ctx.fill();

                console.log(`Canvas ${canvasId} - Circle ${circleCount + 1}: Color: ${color}, X: ${x}, Y: ${y}`);

                circleCount++;
                colorIndex++;
            });
        }

        /**
         * Provide all Letter options
         */
        function showOptions(lettDB) {
            // get and clear options
            const letSelect = document.getElementById('letterSelect');
            letSelect.innerHTML = '';
            // add options in
            const obj = lettDB;
            for (let key in obj) {
                if (obj.hasOwnProperty(key)) {
                    letSelect.innerHTML += `<option value = ${key}>Letter ${key}</option>`;
                }
            }
        }

        function saveState(ctx,frameName) {
            const im = ctx.getImageData(0, 0, canvasDim, canvasDim);
            /* snapshots.push(ctx.getImageData(0, 0, canvasDim, canvasDim));*/
            snaps[frameName] = im;
            return im
        }

        function restoreState(destCtx, frameName, del=false) {
            imga = snaps[frameName];
            if (del) delete snaps[frameName];
            //if (snapshots.length > 0) {
            //    const snapshot = snapshots.pop();
            //    destCtx.putImageData(snapshot, 0, 0);
            //}
            return imga
        }

        function clearState(frameName) {
            delete snaps[frameName];
        }

        /**
         * Interpolates a point along a user-drawn path at given progress (0-1)
         */
        function interpolatePathPoint(path, progress) {
            if (path.length < 2) return path[0];

            // Calculate total path length
            let totalLength = 0;
            const segments = [];
            for (let i = 1; i < path.length; i++) {
                const length = Math.hypot(
                    path[i].x - path[i - 1].x,
                    path[i].y - path[i - 1].y
                );

                segments.push(length);
                totalLength += length;
            }

            const targetLength = totalLength * progress;
            let currentLength = 0;

            // Find segment containing target point
            for (let i = 0; i < segments.length; i++) {
                if (currentLength + segments[i] >= targetLength) {
                    const segmentProgress = (targetLength - currentLength) / segments[i];
                    return {
                        x: path[i].x + (path[i + 1].x - path[i].x) * segmentProgress,
                        y: path[i].y + (path[i + 1].y - path[i].y) * segmentProgress
                    };
                }
                currentLength += segments[i];
            }

            return path[path.length - 1];
        }

        /**
         * Updates the guide display (including stroke directions)
         * stroke directions one arrow w/ three heads 
         */
        function updateGuide() {
            drawLineRule(ruleCtx);
            let ctx = guideCtx;
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

            // Style remaining strokes (gray)
            ({ color: ctx.strokeStyle, lWidth: ctx.lineWidth, lineCap: ctx.lineCap } = guideStyle);

            const letterStrokes = lettDB[currentLetter].strokes;
            for (let i = currStrokeInd; i < letterStrokes.length; i++) {
                let stroke = letterStrokes[i];
                if (stroke.type === 'compound') {
                    stroke.subStrokes.forEach((sub) => sub.drawStroke(ctx, guideStyle));
                } else {
                    stroke.drawStroke(ctx, guideStyle);
                }
            }

            // Highlight current stroke
            if (currStrokeInd < letterStrokes.length) {
                // Stlye highlight strokes
                ({ color: ctx.strokeStyle, lWidth: ctx.lineWidth, lineCap: ctx.lineCap } = hlStyle);
                let stroke = letterStrokes[currStrokeInd];
                if (stroke.type === 'compound') {
                    stroke.subStrokes.forEach((sub) => {
                        sub.drawStroke(ctx, hlStyle);                        
                    })
                    stroke.drawDirections();
                    
                    //stroke.subStrokes.forEach((sub) => {
                    //    sub.drawDirections();
                    //});
                } else {
                    stroke.drawStroke(ctx, hlStyle);
                    stroke.drawDirections();
                }
                // Draw direction arrows for current stroke. if compound only the final one
                
            }
        }

        /**
         * Automatically draws all strokes in sequence. 
         */
        async function autoDraw() {
            if (isAutoDrawing) return;
            isAutoDrawing = true;
            console.log('autoDraw');

            // Disable controls during animation
            document.getElementById('autoDrawBtn').disabled = true;
            document.getElementById('resetBtn').disabled = true;
            document.getElementById('letterSelect').disabled = true;

            // Animate each stroke
            const currLett = lettDB[currentLetter];
            const letterStrokes = currLett.fontStrokes || currLett.strokes;
            console.log(currLett.fontStrokes);
            console.log(letterStrokes);

            // Capture state before autoDraw
            saveState(completedCtx, 'preAuto');

            // Reset canvas
            reset();

            for (let i = 0; i < letterStrokes.length; i++) {

                let stroke = letterStrokes[i];
                if (stroke.type === "compound") {
                    await stroke.animateCompoundStroke(animDur, drawOver);
                }
                else {
                    await stroke.animateStroke(animDur, drawOver);
                }
            }
            // Wait 2 seconds before resetting
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            reset();

            // Re-enable controls
            document.getElementById('autoDrawBtn').disabled = false;
            document.getElementById('resetBtn').disabled = false;
            document.getElementById('letterSelect').disabled = false;

            // Restore state after autoDraw to what it was before
            restoreState(completedCtx,'preAuto', true); 
            isAutoDrawing = false;
        }

        function autoDrawOver() {
            drawOver = true;
            autoDraw();
            drawOver = false;
        }
        /**
         * Resets the practice session
         */
        function reset() {
            console.log(`reset`); // leter
            currStrokeInd = 0;
            completedCtx.clearRect(0, 0, completedCanvas.width, completedCanvas.height);
            guideCtx.clearRect(0, 0, guideCanvas.width, guideCanvas.height);
            drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
            document.querySelector('.instruction').textContent = 'Follow the highlighted stroke';
            document.querySelector('.instruction').style.color = '#444';
            accuracyDisplay.textContent = '';
            updateGuide();
        }

        // Event handlers
        /**
         * handle the begining of a drawing attempt either with mouse or finger
         */
        function handleStart(e) {
            if (isAutoDrawing) return;
            isDrawing = true;
            const point = getEventPoint(e);
            drawingPath = [point];
            accuracyDisplay.textContent = '';
        }

        function handleMove(e) {
            if (!isDrawing || isAutoDrawing) return;

            const point = getEventPoint(e);
            drawingPath.push(point);

            // Draw the new line segment
            drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
            drawCtx.beginPath();
            drawCtx.strokeStyle = '#2196f3';
            drawCtx.lineWidth = 20;
            drawCtx.lineCap = 'round';

            drawCtx.moveTo(drawingPath[0].x, drawingPath[0].y);
            for (let i = 1; i < drawingPath.length; i++) {
                drawCtx.lineTo(drawingPath[i].x, drawingPath[i].y);
            }
            drawCtx.stroke();
        }

        function handleEnd() {
            if (!isDrawing || isAutoDrawing) return;
            isDrawing = false;

            const currentStrokeData = lettDB[currentLetter].strokes[currStrokeInd];
            if (!currentStrokeData) return
            const accuracy = currentStrokeData.calculateAccuracy(drawingPath);

            accuracyDisplay.textContent = `Accuracy: ${Math.round(accuracy)}%`;

            if (accuracy >= 50) {
                // Add to completed strokes console.log('passed acc');

                // completed style 
                completedCtx.strokeStyle = '#2196f3';
                completedCtx.lineWidth = 20;
                completedCtx.lineCap = 'round';

                if (currentStrokeData.type === 'compound') {
                    currentStrokeData.subStrokes.forEach((sub) => sub.drawStroke(completedCtx, completeStyle));
                } else {
                    currentStrokeData.drawStroke(completedCtx, completeStyle);
                }

                currStrokeInd++;
                updateGuide();
                if (currStrokeInd >= lettDB[currentLetter].strokes.length) {
                    document.querySelector('.instruction').textContent = 'Great job! Letter completed!';
                    document.querySelector('.instruction').style.color = '#4CAF50';
                } else {

                }
            }

            // Clear drawing
            drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
        }

        /**
         * Helper function to get coordinates from mouse or touch event
         */
        function getEventPoint(e) {
            const rect = drawCanvas.getBoundingClientRect();
            const point = e.touches ? e.touches[0] : e;
            return {
                x: point.clientX - rect.left,
                y: point.clientY - rect.top
            };
        }


        let lettDB = new LetterDatabase(letters);
        console.log(lettDB);
        showOptions(lettDB);

        // App state
        let currentLetter = document.getElementById('letterSelect').value; //'A';
        let currStrokeInd = 0;
        let isDrawing = false;
        let lastPoint = null;
        let drawingPath = [];
        let isAutoDrawing = false;
        let snapshots = [];
        let snaps = {};
        let drawOver = false;

        drawFontLetter(currentLetter);
        markPoints('drawCanvas'); // top level canvas
        
        // Event Listeners
        drawCanvas.addEventListener('mousedown', handleStart);
        drawCanvas.addEventListener('mousemove', handleMove);
        drawCanvas.addEventListener('mouseup', handleEnd);
        drawCanvas.addEventListener('mouseout', handleEnd);
        drawCanvas.addEventListener('touchstart', e => {
            e.preventDefault();
            handleStart(e);
        });
        drawCanvas.addEventListener('touchmove', e => {
            e.preventDefault();
            handleMove(e);
        });
        drawCanvas.addEventListener('touchend', handleEnd);

        document.getElementById('letterSelect').addEventListener('change', e => {
            currentLetter = e.target.value;
            reset();
            drawFontLetter(currentLetter);
        });
        document.getElementById('resetBtn').addEventListener('click', reset);
        document.getElementById('autoDrawBtn').addEventListener('click', autoDraw);
        //document.getElementById('autoDrawOver').addEventListener('click', autoDrawOver);
        document.getElementById('toggleRule').addEventListener('click', () => {
            rulePaper = !rulePaper;
            updateGuide();
        });

        // Initialize
        updateGuide();
    </script>
</body>
</html>
